import { utils, ExtensionType, settings, extensions } from 'pixijs/core';
import { BitmapFontData, BitmapFont, TextFormat, XMLStringFormat } from 'pixijs/text-bitmap';
import { parseStringPromise } from 'xml2js';

function xmlJsonParser(xml) {
  const data = new BitmapFontData();
  const font = xml.font;
  const info = font.info;
  const common = font.common;
  const pages = font.pages;
  const chars = font.chars;
  const kernings = font.kernings;
  const distanceField = font.distanceField;
  info.forEach((element) => {
    data.info.push({
      face: element.$.face,
      size: parseInt(element.$.size, 10)
    });
  });
  common.forEach((element) => {
    data.common.push({
      lineHeight: parseInt(element.$.lineHeight, 10)
    });
  });
  pages.forEach((element) => {
    element.page.forEach((page) => {
      data.page.push({
        id: parseInt(page.$.id, 10),
        file: page.$.file
      });
    });
  });
  chars.forEach((info2) => {
    const charArr = info2.char;
    charArr.forEach((char) => {
      data.char.push({
        id: parseInt(char.$.id, 10),
        page: parseInt(char.$.page, 10),
        x: parseInt(char.$.x, 10),
        y: parseInt(char.$.y, 10),
        width: parseInt(char.$.width, 10),
        height: parseInt(char.$.height, 10),
        xoffset: parseInt(char.$.xoffset, 10),
        yoffset: parseInt(char.$.yoffset, 10),
        xadvance: parseInt(char.$.xadvance, 10)
      });
    });
  });
  kernings?.forEach((info2) => {
    info2.kerning?.forEach((kerning) => data.kerning.push({
      first: parseInt(kerning.$.first, 10),
      second: parseInt(kerning.$.second, 10),
      amount: parseInt(kerning.$.amount, 10)
    }));
  });
  distanceField?.forEach((df) => {
    data.distanceField.push({
      distanceRange: parseInt(df.$.distanceRange, 10),
      fieldType: df.$.fieldType
    });
  });
  return data;
}
async function _loadBitmap(src, data, loader) {
  const pages = data.page;
  const textureUrls = [];
  for (let i = 0; i < pages.length; ++i) {
    const pageFile = pages[i].file;
    const url = utils.path.join(utils.path.dirname(src), pageFile);
    textureUrls.push(url);
  }
  const loadedTextures = await loader.load(textureUrls);
  const textures = textureUrls.map((url) => loadedTextures[url]);
  return BitmapFont.install(data, textures, true);
}
async function xmlStringFormatTest(data) {
  if (typeof data === "string" && data.includes("<font>")) {
    const xml = xmlJsonParser(await parseStringPromise(data));
    return xml.page.length > 0 && xml.info[0].face !== null;
  }
  return false;
}
const validExtensions = [".xml", ".fnt"];
const loadNodeBitmapFont = {
  extension: ExtensionType.LoadParser,
  test(url) {
    return validExtensions.includes(utils.path.extname(url));
  },
  async testParse(data) {
    const isText = TextFormat.test(data);
    const isXMLText = await xmlStringFormatTest(data);
    return isText || isXMLText;
  },
  async parse(asset, data, loader) {
    const isText = TextFormat.test(asset);
    if (isText) {
      const parsed = TextFormat.parse(asset);
      return await _loadBitmap(data.src, parsed, loader);
    }
    return await _loadBitmap(data.src, XMLStringFormat.parse(asset), loader);
  },
  async load(url, _asset, loader) {
    const response = await settings.ADAPTER.fetch(url);
    const text = await response.text();
    const data = xmlJsonParser(await parseStringPromise(text));
    return await _loadBitmap(url, data, loader);
  },
  unload(bitmapFont) {
    bitmapFont.destroy();
  }
};
extensions.add(loadNodeBitmapFont);

export { loadNodeBitmapFont };
//# sourceMappingURL=loadNodeBitmapFont.mjs.map
