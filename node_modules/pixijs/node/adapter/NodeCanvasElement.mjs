import canvasModule from 'canvas';
import createGLContext from 'gl';
import { utils } from 'pixijs/core';

const { Canvas, CanvasRenderingContext2D, Image } = canvasModule;
function putImageData(gl, canvas) {
  const { width, height } = canvas;
  const ctx = canvas["_ctx"];
  const data = ctx.getImageData(0, 0, width, height);
  const pixels = new Uint8Array(width * height * 4);
  gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  for (let i = 0; i < height; i++) {
    for (let j = 0; j < width; j++) {
      const col = j;
      const row = height - i - 1;
      for (let k = 0; k < 4; k++) {
        const idx = 4 * (row * width + col) + k;
        const idx2 = 4 * (i * width + col) + k;
        data.data[idx] = pixels[idx2];
      }
    }
  }
  ctx.putImageData(data, 0, 0);
  return ctx;
}
class NodeCanvasElement extends canvasModule.Canvas {
  constructor(width = 1, height = 1, type) {
    super(width, height, type);
    this._event = new utils.EventEmitter();
    this.style = {};
  }
  get width() {
    return super["width"];
  }
  set width(value) {
    if (this._gl) {
      const ext = this._gl.getExtension("STACKGL_resize_drawingbuffer");
      ext.resize(value, this.height);
    }
    super["width"] = value;
  }
  get height() {
    return super["height"];
  }
  set height(value) {
    if (this._gl) {
      const ext = this._gl.getExtension("STACKGL_resize_drawingbuffer");
      ext.resize(this.width, value);
    }
    super["height"] = value;
  }
  get clientWidth() {
    return super["width"];
  }
  get clientHeight() {
    return super["height"];
  }
  _updateCtx() {
    const gl = this._gl;
    if (gl) {
      putImageData(gl, this);
    }
    return this._ctx;
  }
  getContext(type, options) {
    switch (type) {
      case "2d": {
        if (this._contextType && this._contextType !== "2d")
          return null;
        if (this._ctx)
          return this._ctx;
        this._ctx = super.getContext("2d", options);
        this._contextType = "2d";
        return this._ctx;
      }
      case "webgl":
      case "experimental-webgl": {
        if (this._contextType && this._contextType !== "webgl")
          return null;
        if (this._gl)
          return this._gl;
        const { width, height } = this;
        this._ctx = super.getContext("2d", options);
        const ctx = createGLContext(width, height, options);
        const _getUniformLocation = ctx.getUniformLocation;
        ctx.getUniformLocation = function(program, name) {
          if (program._uniforms && !/\[\d+\]$/.test(name)) {
            const reg = new RegExp(`${name}\\[\\d+\\]$`);
            for (let i = 0; i < program._uniforms.length; i++) {
              const _name = program._uniforms[i].name;
              if (reg.test(_name)) {
                name = _name;
              }
            }
          }
          return _getUniformLocation.call(this, program, name);
        };
        ctx.canvas = this;
        const _texImage2D = ctx.texImage2D;
        ctx.texImage2D = function(...args) {
          let pixels = args[args.length - 1];
          if (pixels?._image)
            pixels = pixels._image;
          if (pixels instanceof Image) {
            const canvas = new Canvas(pixels.width, pixels.height);
            canvas.getContext("2d").drawImage(pixels, 0, 0);
            args[args.length - 1] = canvas;
          }
          return _texImage2D.apply(this, args);
        };
        this._gl = ctx;
        this._contextType = "webgl";
        return this._gl;
      }
      default:
        return null;
    }
  }
  toBuffer(...args) {
    const gl = this._gl;
    if (gl) {
      putImageData(gl, this);
    }
    return super.toBuffer(...args);
  }
  toDataURL(...args) {
    const gl = this._gl;
    if (gl) {
      putImageData(gl, this);
    }
    return super.toDataURL(...args);
  }
  addEventListener(type, listener) {
    return this._event.addListener(type, listener);
  }
  removeEventListener(type, listener) {
    if (listener) {
      return this._event.removeListener(type, listener);
    }
    return this._event.removeAllListeners(type);
  }
  dispatchEvent(event) {
    event.target = this;
    return this._event.emit(event.type, event);
  }
}
const _drawImage = CanvasRenderingContext2D.prototype.drawImage;
CanvasRenderingContext2D.prototype.drawImage = function(img, ...args) {
  const _img = img;
  if (img instanceof Canvas && _img["_gl"])
    _img._updateCtx();
  return _drawImage.call(this, img, ...args);
};

export { NodeCanvasElement };
//# sourceMappingURL=NodeCanvasElement.mjs.map
