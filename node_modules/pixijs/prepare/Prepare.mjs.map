{"version":3,"file":"Prepare.mjs","sources":["../src/Prepare.ts"],"sourcesContent":["import { BaseTexture, extensions, ExtensionType } from 'pixijs/core';\nimport { Graphics } from 'pixijs/graphics';\nimport type { IDisplayObjectExtended } from './BasePrepare';\nimport { BasePrepare } from './BasePrepare';\n\nimport type { Renderer, IRenderer, ISystem, ExtensionMetadata } from 'pixijs/core';\n\n/**\n * Built-in hook to upload PIXI.Texture objects to the GPU.\n * @private\n * @param renderer - instance of the webgl renderer\n * @param item - Item to check\n * @returns If item was uploaded.\n */\nfunction uploadBaseTextures(renderer: IRenderer | BasePrepare, item: IDisplayObjectExtended | BaseTexture): boolean\n{\n    if (item instanceof BaseTexture)\n    {\n        // if the texture already has a GL texture, then the texture has been prepared or rendered\n        // before now. If the texture changed, then the changer should be calling texture.update() which\n        // reuploads the texture without need for preparing it again\n        if (!item._glTextures[(renderer as Renderer).CONTEXT_UID])\n        {\n            (renderer as Renderer).texture.bind(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to upload PIXI.Graphics to the GPU.\n * @private\n * @param renderer - instance of the webgl renderer\n * @param item - Item to check\n * @returns If item was uploaded.\n */\nfunction uploadGraphics(renderer: IRenderer | BasePrepare, item: IDisplayObjectExtended): boolean\n{\n    if (!(item instanceof Graphics))\n    {\n        return false;\n    }\n\n    const { geometry } = item;\n\n    // update dirty graphics to get batches\n    item.finishPoly();\n    geometry.updateBatches();\n\n    const { batches } = geometry;\n\n    // upload all textures found in styles\n    for (let i = 0; i < batches.length; i++)\n    {\n        const { texture } = batches[i].style;\n\n        if (texture)\n        {\n            uploadBaseTextures(renderer, texture.baseTexture);\n        }\n    }\n\n    // if its not batchable - update vao for particular shader\n    if (!geometry.batchable)\n    {\n        (renderer as Renderer).geometry.bind(geometry, (item as any)._resolveDirectShader((renderer as Renderer)));\n    }\n\n    return true;\n}\n\n/**\n * Built-in hook to find graphics.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns if a PIXI.Graphics object was found.\n */\nfunction findGraphics(item: IDisplayObjectExtended, queue: Array<any>): boolean\n{\n    if (item instanceof Graphics)\n    {\n        queue.push(item);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * The prepare plugin provides renderer-specific plugins for pre-rendering DisplayObjects. These plugins are useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @example\n * import { Application, Graphics } from 'pixijs/browser';\n *\n * // Create a new application\n * const app = new Application();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // create a display object\n * const rect = new Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.plugins.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n * @memberof PIXI\n */\nexport class Prepare extends BasePrepare implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'prepare',\n        type: ExtensionType.RendererSystem,\n    };\n\n    /**\n     * @param {PIXI.Renderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        this.uploadHookHelper = this.renderer;\n\n        // Add textures and graphics to upload\n        this.registerFindHook(findGraphics);\n        this.registerUploadHook(uploadBaseTextures);\n        this.registerUploadHook(uploadGraphics);\n    }\n}\n\nextensions.add(Prepare);\n"],"names":[],"mappings":";;;;AAcA,SAAA,kBAAA,CAA4B,UAAmC,IAC/D,EAAA;AACI,EAAA,IAAI,gBAAgB,WACpB,EAAA;AAII,IAAA,IAAI,CAAC,IAAA,CAAK,WAAa,CAAA,QAAA,CAAsB,WAC7C,CAAA,EAAA;AACI,MAAC,QAAA,CAAsB,OAAQ,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AAAA,KAC5C;AAEA,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAEA,EAAO,OAAA,KAAA,CAAA;AACX,CAAA;AASA,SAAA,cAAA,CAAwB,UAAmC,IAC3D,EAAA;AACI,EAAI,IAAA,kBAAkB,QACtB,CAAA,EAAA;AACI,IAAO,OAAA,KAAA,CAAA;AAAA,GACX;AAEA,EAAA,MAAM,EAAE,QAAa,EAAA,GAAA,IAAA,CAAA;AAGrB,EAAA,IAAA,CAAK,UAAW,EAAA,CAAA;AAChB,EAAA,QAAA,CAAS,aAAc,EAAA,CAAA;AAEvB,EAAA,MAAM,EAAE,OAAY,EAAA,GAAA,QAAA,CAAA;AAGpB,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,OAAA,CAAQ,QAAQ,CACpC,EAAA,EAAA;AACI,IAAM,MAAA,EAAE,OAAY,EAAA,GAAA,OAAA,CAAQ,CAAG,CAAA,CAAA,KAAA,CAAA;AAE/B,IAAA,IAAI,OACJ,EAAA;AACI,MAAmB,kBAAA,CAAA,QAAA,EAAU,QAAQ,WAAW,CAAA,CAAA;AAAA,KACpD;AAAA,GACJ;AAGA,EAAI,IAAA,CAAC,SAAS,SACd,EAAA;AACI,IAAC,SAAsB,QAAS,CAAA,IAAA,CAAK,UAAW,IAAa,CAAA,oBAAA,CAAsB,QAAqB,CAAC,CAAA,CAAA;AAAA,GAC7G;AAEA,EAAO,OAAA,IAAA,CAAA;AACX,CAAA;AASA,SAAA,YAAA,CAAsB,MAA8B,KACpD,EAAA;AACI,EAAA,IAAI,gBAAgB,QACpB,EAAA;AACI,IAAA,KAAA,CAAM,KAAK,IAAI,CAAA,CAAA;AAEf,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAEA,EAAO,OAAA,KAAA,CAAA;AACX,CAAA;AAgCO,MAAM,gBAAgB,WAC7B,CAAA;AAAA,EAUI,YAAY,QACZ,EAAA;AACI,IAAA,KAAA,CAAM,QAAQ,CAAA,CAAA;AAEd,IAAA,IAAA,CAAK,mBAAmB,IAAK,CAAA,QAAA,CAAA;AAG7B,IAAA,IAAA,CAAK,iBAAiB,YAAY,CAAA,CAAA;AAClC,IAAA,IAAA,CAAK,mBAAmB,kBAAkB,CAAA,CAAA;AAC1C,IAAA,IAAA,CAAK,mBAAmB,cAAc,CAAA,CAAA;AAAA,GAC1C;AACJ,CAAA;AAtBa,QAGF,SAA+B,GAAA;AAAA,EAClC,IAAM,EAAA,SAAA;AAAA,EACN,MAAM,aAAc,CAAA,cAAA;AACxB,CAAA,CAAA;AAkBJ,UAAA,CAAW,IAAI,OAAO,CAAA;;;;"}