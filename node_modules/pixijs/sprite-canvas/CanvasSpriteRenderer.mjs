import { Matrix, SCALE_MODES, groupD8, BLEND_MODES, ExtensionType, extensions } from 'pixijs/core';
import { canvasUtils } from 'pixijs/renderer/canvas';

const canvasRenderWorldTransform = new Matrix();
class CanvasSpriteRenderer {
  constructor(renderer) {
    this.renderer = renderer;
  }
  render(sprite) {
    const texture = sprite._texture;
    const renderer = this.renderer;
    const context = renderer.canvasContext.activeContext;
    const activeResolution = renderer.canvasContext.activeResolution;
    if (!texture.valid) {
      return;
    }
    const sourceWidth = texture._frame.width;
    const sourceHeight = texture._frame.height;
    let destWidth = texture._frame.width;
    let destHeight = texture._frame.height;
    if (texture.trim) {
      destWidth = texture.trim.width;
      destHeight = texture.trim.height;
    }
    let wt = sprite.transform.worldTransform;
    let dx = 0;
    let dy = 0;
    const source = texture.baseTexture.getDrawableSource();
    if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.valid || !source) {
      return;
    }
    renderer.canvasContext.setBlendMode(sprite.blendMode, true);
    context.globalAlpha = sprite.worldAlpha;
    const smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;
    const smoothProperty = renderer.canvasContext.smoothProperty;
    if (smoothProperty && context[smoothProperty] !== smoothingEnabled) {
      context[smoothProperty] = smoothingEnabled;
    }
    if (texture.trim) {
      dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;
      dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;
    } else {
      dx = (0.5 - sprite.anchor.x) * texture.orig.width;
      dy = (0.5 - sprite.anchor.y) * texture.orig.height;
    }
    if (texture.rotate) {
      wt.copyTo(canvasRenderWorldTransform);
      wt = canvasRenderWorldTransform;
      groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
      dx = 0;
      dy = 0;
    }
    dx -= destWidth / 2;
    dy -= destHeight / 2;
    renderer.canvasContext.setContextTransform(wt, sprite.roundPixels, 1);
    if (sprite.roundPixels) {
      dx = dx | 0;
      dy = dy | 0;
    }
    const resolution = texture.baseTexture.resolution;
    const outerBlend = renderer.canvasContext._outerBlend;
    if (outerBlend) {
      context.save();
      context.beginPath();
      context.rect(dx * activeResolution, dy * activeResolution, destWidth * activeResolution, destHeight * activeResolution);
      context.clip();
    }
    if (sprite.tint !== 16777215) {
      if (sprite._cachedTint !== sprite.tint || sprite._tintedCanvas.tintId !== sprite._texture._updateID) {
        sprite._cachedTint = sprite.tint;
        sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tint);
      }
      context.drawImage(sprite._tintedCanvas, 0, 0, Math.floor(sourceWidth * resolution), Math.floor(sourceHeight * resolution), Math.floor(dx * activeResolution), Math.floor(dy * activeResolution), Math.floor(destWidth * activeResolution), Math.floor(destHeight * activeResolution));
    } else {
      context.drawImage(source, texture._frame.x * resolution, texture._frame.y * resolution, Math.floor(sourceWidth * resolution), Math.floor(sourceHeight * resolution), Math.floor(dx * activeResolution), Math.floor(dy * activeResolution), Math.floor(destWidth * activeResolution), Math.floor(destHeight * activeResolution));
    }
    if (outerBlend) {
      context.restore();
    }
    renderer.canvasContext.setBlendMode(BLEND_MODES.NORMAL);
  }
  destroy() {
    this.renderer = null;
  }
}
CanvasSpriteRenderer.extension = {
  name: "sprite",
  type: ExtensionType.CanvasRendererPlugin
};
extensions.add(CanvasSpriteRenderer);

export { CanvasSpriteRenderer };
//# sourceMappingURL=CanvasSpriteRenderer.mjs.map
