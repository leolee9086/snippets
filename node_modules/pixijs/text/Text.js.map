{"version":3,"file":"Text.js","sources":["../src/Text.ts"],"sourcesContent":["/* eslint max-depth: [2, 8] */\nimport { Sprite } from 'pixijs/sprite';\nimport { Texture, settings, Rectangle, utils } from 'pixijs/core';\nimport { TEXT_GRADIENT } from './const';\nimport { TextStyle } from './TextStyle';\nimport { TextMetrics } from './TextMetrics';\n\nimport type { Renderer } from 'pixijs/core';\nimport type { IDestroyOptions } from 'pixijs/display';\nimport type { ICanvas, ICanvasRenderingContext2D } from 'pixijs/settings';\nimport type { ITextStyle } from './TextStyle';\n\nconst defaultDestroyOptions: IDestroyOptions = {\n    texture: true,\n    children: false,\n    baseTexture: true,\n};\n\ninterface ModernContext2D extends ICanvasRenderingContext2D\n{\n    // for chrome less 94\n    textLetterSpacing?: number;\n    // for chrome greater 94\n    letterSpacing?: number;\n}\n\n/**\n * A Text Object will create a line or multiple lines of text.\n *\n * The text is created using the [Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API).\n *\n * The primary advantage of this class over BitmapText is that you have great control over the style of the text,\n * which you can change at runtime.\n *\n * The primary disadvantages is that each piece of text has it's own texture, which can use more memory.\n * When text changes, this texture has to be re-generated and re-uploaded to the GPU, taking up time.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and give the `wordWrapWidth` property a value.\n *\n * A Text can be created directly from a string and a style object,\n * which can be generated [here](https://pixijs.io/pixi-text-style).\n * @example\n * import { Text } from 'pixijs/browser';\n *\n * const text = new Text('This is a PixiJS text', {\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * @memberof PIXI\n */\nexport class Text extends Sprite\n{\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** The canvas element that everything is drawn to. */\n    public canvas: ICanvas;\n    /** The canvas 2d context that everything is drawn with. */\n    public context: ModernContext2D;\n    public localStyleID: number;\n    public dirty: boolean;\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default PIXI.settings.RESOLUTION\n     */\n    _resolution: number;\n    _autoResolution: boolean;\n\n    /**\n     * Private tracker for the current text.\n     * @private\n     */\n    protected _text: string;\n\n    /**\n     * Private tracker for the current font.\n     * @private\n     */\n    protected _font: string;\n\n    /**\n     * Private tracker for the current style.\n     * @private\n     */\n    protected _style: TextStyle;\n\n    /**\n     * Private listener to track style changes.\n     * @private\n     */\n    protected _styleListener: () => void;\n\n    /**\n     * Keep track if this Text object created it's own canvas\n     * element (`true`) or uses the constructor argument (`false`).\n     * Used to workaround a GC issues with Safari < 13 when\n     * destroying Text. See `destroy` for more info.\n     */\n    private _ownCanvas: boolean;\n\n    /**\n     * @param text - The string that you would like the text to display\n     * @param {object|PIXI.TextStyle} [style] - The style parameters\n     * @param canvas - The canvas element for drawing text\n     */\n    constructor(text?: string | number, style?: Partial<ITextStyle> | TextStyle, canvas?: ICanvas)\n    {\n        let ownCanvas = false;\n\n        if (!canvas)\n        {\n            canvas = settings.ADAPTER.createCanvas();\n            ownCanvas = true;\n        }\n\n        canvas.width = 3;\n        canvas.height = 3;\n\n        const texture = Texture.from(canvas);\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        super(texture);\n\n        this._ownCanvas = ownCanvas;\n        this.canvas = canvas;\n        this.context = canvas.getContext('2d', {\n            // required for trimming to work without warnings\n            willReadFrequently: true,\n        });\n\n        this._resolution = settings.RESOLUTION;\n        this._autoResolution = true;\n        this._text = null;\n        this._style = null;\n        this._styleListener = null;\n        this._font = '';\n\n        this.text = text;\n        this.style = style;\n\n        this.localStyleID = -1;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n     */\n    public updateText(respectDirty: boolean): void\n    {\n        const style = this._style;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        this._font = this._style.toFontString();\n\n        const context = this.context;\n        const measured = TextMetrics.measureText(this._text || ' ', this._style, this._style.wordWrap, this.canvas);\n        const width = measured.width;\n        const height = measured.height;\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        this.canvas.width = Math.ceil(Math.ceil((Math.max(1, width) + (style.padding * 2))) * this._resolution);\n        this.canvas.height = Math.ceil(Math.ceil((Math.max(1, height) + (style.padding * 2))) * this._resolution);\n\n        context.scale(this._resolution, this._resolution);\n\n        context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        context.font = this._font;\n        context.lineWidth = style.strokeThickness;\n        context.textBaseline = style.textBaseline;\n        context.lineJoin = style.lineJoin;\n        context.miterLimit = style.miterLimit;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * this._resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const dropShadowColor = style.dropShadowColor;\n                const rgb = utils.hex2rgb(typeof dropShadowColor === 'number'\n                    ? dropShadowColor\n                    : utils.string2hex(dropShadowColor));\n                const dropShadowBlur = style.dropShadowBlur * this._resolution;\n                const dropShadowDistance = style.dropShadowDistance * this._resolution;\n\n                context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${style.dropShadowAlpha})`;\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(style.dropShadowAngle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                // set canvas text styles\n                context.fillStyle = this._generateFillStyle(style, lines, measured);\n                // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n                //       the setter converts to string. See this thread for more details:\n                //       https://github.com/microsoft/TypeScript/issues/2521\n                context.strokeStyle = style.stroke as string;\n\n                context.shadowColor = 'black';\n                context.shadowBlur = 0;\n                context.shadowOffsetX = 0;\n                context.shadowOffsetY = 0;\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = style.strokeThickness / 2;\n                linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent\n                    + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style.stroke && style.strokeThickness)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style.fill)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n\n        this.updateTexture();\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private drawLetterSpacing(text: string, x: number, y: number, isStroke = false): void\n    {\n        const style = this._style;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        // Checking that we can use moddern canvas2D api\n        // https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n        // note: this is unstable API, Chrome less 94 use a `textLetterSpacing`, newest use a letterSpacing\n        // eslint-disable-next-line max-len\n        const supportLetterSpacing = Text.experimentalLetterSpacing\n            && ('letterSpacing' in CanvasRenderingContext2D.prototype\n                || 'textLetterSpacing' in CanvasRenderingContext2D.prototype);\n\n        if (letterSpacing === 0 || supportLetterSpacing)\n        {\n            if (supportLetterSpacing)\n            {\n                this.context.letterSpacing = letterSpacing;\n                this.context.textLetterSpacing = letterSpacing;\n            }\n\n            if (isStroke)\n            {\n                this.context.strokeText(text, x, y);\n            }\n            else\n            {\n                this.context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        // Using Array.from correctly splits characters whilst keeping emoji together.\n        // This is not supported on IE as it requires ES6, so regular text splitting occurs.\n        // This also doesn't account for emoji that are multiple emoji put together to make something else.\n        // Handling all of this would require a big library itself.\n        // https://medium.com/@giltayar/iterating-over-emoji-characters-the-es6-way-f06e4589516\n        // https://github.com/orling/grapheme-splitter\n        const stringArray = Array.from ? Array.from(text) : text.split('');\n        let previousWidth = this.context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                this.context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                this.context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = this.context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    /** Updates texture size based on canvas size. */\n    private updateTexture(): void\n    {\n        const canvas = this.canvas;\n\n        if (this._style.trim)\n        {\n            const trimmed = utils.trimCanvas(canvas);\n\n            if (trimmed.data)\n            {\n                canvas.width = trimmed.width;\n                canvas.height = trimmed.height;\n                this.context.putImageData(trimmed.data, 0, 0);\n            }\n        }\n\n        const texture = this._texture;\n        const style = this._style;\n        const padding = style.trim ? 0 : style.padding;\n        const baseTexture = texture.baseTexture;\n\n        texture.trim.width = texture._frame.width = canvas.width / this._resolution;\n        texture.trim.height = texture._frame.height = canvas.height / this._resolution;\n        texture.trim.x = -padding;\n        texture.trim.y = -padding;\n\n        texture.orig.width = texture._frame.width - (padding * 2);\n        texture.orig.height = texture._frame.height - (padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);\n\n        texture.updateUvs();\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._render(renderer);\n    }\n\n    /** Updates the transform on all children of this container for rendering. */\n    public updateTransform(): void\n    {\n        this.updateText(true);\n\n        super.updateTransform();\n    }\n\n    public getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle\n    {\n        this.updateText(true);\n\n        if (this._textureID === -1)\n        {\n            // texture was updated: recalculate transforms\n            skipUpdate = false;\n        }\n\n        return super.getBounds(skipUpdate, rect);\n    }\n\n    /**\n     * Gets the local bounds of the text object.\n     * @param rect - The output rectangle.\n     * @returns The bounds.\n     */\n    public getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /** Calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account. */\n    protected _calculateBounds(): void\n    {\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        this._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n     * @param style - The style.\n     * @param lines - The lines of text.\n     * @param metrics\n     * @returns The fill style\n     */\n    private _generateFillStyle(\n        style: TextStyle, lines: string[], metrics: TextMetrics\n    ): string | CanvasGradient | CanvasPattern\n    {\n        // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n        //       the setter converts to string. See this thread for more details:\n        //       https://github.com/microsoft/TypeScript/issues/2521\n        const fillStyle: string | string[] | CanvasGradient | CanvasPattern = style.fill as any;\n\n        if (!Array.isArray(fillStyle))\n        {\n            return fillStyle;\n        }\n        else if (fillStyle.length === 1)\n        {\n            return fillStyle[0];\n        }\n\n        // the gradient will be evenly spaced out according to how large the array is.\n        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n        let gradient: string[] | CanvasGradient;\n\n        // a dropshadow will enlarge the canvas and result in the gradient being\n        // generated with the incorrect dimensions\n        const dropShadowCorrection = (style.dropShadow) ? style.dropShadowDistance : 0;\n\n        // should also take padding into account, padding can offset the gradient\n        const padding = style.padding || 0;\n\n        const width = (this.canvas.width / this._resolution) - dropShadowCorrection - (padding * 2);\n        const height = (this.canvas.height / this._resolution) - dropShadowCorrection - (padding * 2);\n\n        // make a copy of the style settings, so we can manipulate them later\n        const fill = fillStyle.slice();\n        const fillGradientStops = style.fillGradientStops.slice();\n\n        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n        if (!fillGradientStops.length)\n        {\n            const lengthPlus1 = fill.length + 1;\n\n            for (let i = 1; i < lengthPlus1; ++i)\n            {\n                fillGradientStops.push(i / lengthPlus1);\n            }\n        }\n\n        // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n        fill.unshift(fillStyle[0]);\n        fillGradientStops.unshift(0);\n\n        fill.push(fillStyle[fillStyle.length - 1]);\n        fillGradientStops.push(1);\n\n        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL)\n        {\n            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n            gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n\n            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n\n            // Actual height of the text itself, not counting spacing for lineHeight/leading/dropShadow etc\n            const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n\n            for (let i = 0; i < lines.length; i++)\n            {\n                const lastLineBottom = (metrics.lineHeight * (i - 1)) + textHeight;\n                const thisLineTop = metrics.lineHeight * i;\n                let thisLineGradientStart = thisLineTop;\n\n                // Handle case where last & this line overlap\n                if (i > 0 && lastLineBottom > thisLineTop)\n                {\n                    thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;\n                }\n\n                const thisLineBottom = thisLineTop + textHeight;\n                const nextLineTop = metrics.lineHeight * (i + 1);\n                let thisLineGradientEnd = thisLineBottom;\n\n                // Handle case where this & next line overlap\n                if (i + 1 < lines.length && nextLineTop < thisLineBottom)\n                {\n                    thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;\n                }\n\n                // textHeight, but as a 0-1 size in global gradient stop space\n                const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n\n                for (let j = 0; j < fill.length; j++)\n                {\n                    // 0-1 stop point for the current line, multiplied to global space afterwards\n                    let lineStop = 0;\n\n                    if (typeof fillGradientStops[j] === 'number')\n                    {\n                        lineStop = fillGradientStops[j];\n                    }\n                    else\n                    {\n                        lineStop = j / fill.length;\n                    }\n\n                    let globalStop = Math.min(1, Math.max(0,\n                        (thisLineGradientStart / height) + (lineStop * gradStopLineHeight)));\n\n                    // There's potential for floating point precision issues at the seams between gradient repeats.\n                    globalStop = Number(globalStop.toFixed(5));\n                    gradient.addColorStop(globalStop, fill[j]);\n                }\n            }\n        }\n        else\n        {\n            // start the gradient at the center left of the canvas, and end at the center right of the canvas\n            gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n\n            // can just evenly space out the gradients in this case, as multiple lines makes no difference\n            // to an even left to right gradient\n            const totalIterations = fill.length + 1;\n            let currentIteration = 1;\n\n            for (let i = 0; i < fill.length; i++)\n            {\n                let stop: number;\n\n                if (typeof fillGradientStops[i] === 'number')\n                {\n                    stop = fillGradientStops[i];\n                }\n                else\n                {\n                    stop = currentIteration / totalIterations;\n                }\n                gradient.addColorStop(stop, fill[i]);\n                currentIteration++;\n            }\n        }\n\n        return gradient;\n    }\n\n    /**\n     * Destroys this text object.\n     *\n     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n     * the majority of the time the texture will not be shared with any other Sprites.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        if (typeof options === 'boolean')\n        {\n            options = { children: options };\n        }\n\n        options = Object.assign({}, defaultDestroyOptions, options);\n\n        super.destroy(options);\n\n        // set canvas width and height to 0 to workaround memory leak in Safari < 13\n        // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12\n        if (this._ownCanvas)\n        {\n            this.canvas.height = this.canvas.width = 0;\n        }\n\n        // make sure to reset the context and canvas.. dont want this hanging around in memory!\n        this.context = null;\n        this.canvas = null;\n\n        this._style = null;\n    }\n\n    /** The width of the Text, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value: number)\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /** The height of the Text, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value: number)\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     */\n    get style(): TextStyle | Partial<ITextStyle>\n    {\n        // TODO: Can't have different types for getter and setter. The getter shouldn't have the ITextStyle\n        //       since the setter creates the TextStyle. See this thread for more details:\n        //       https://github.com/microsoft/TypeScript/issues/2521\n        return this._style;\n    }\n\n    set style(style: TextStyle | Partial<ITextStyle>)\n    {\n        style = style || {};\n\n        if (style instanceof TextStyle)\n        {\n            this._style = style;\n        }\n        else\n        {\n            this._style = new TextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    get text(): string\n    {\n        return this._text;\n    }\n\n    set text(text: string | number)\n    {\n        text = String(text === null || text === undefined ? '' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n}\n"],"names":["Sprite","settings","Texture","Rectangle","TextMetrics","utils","TEXT_GRADIENT","TextStyle"],"mappings":"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"}