{"version":3,"file":"MaskData.js","sources":["../../src/mask/MaskData.ts"],"sourcesContent":["import { MASK_TYPES } from 'pixijs/constants';\nimport { settings } from 'pixijs/settings';\nimport type { ISpriteMaskFilter } from 'pixijs/core';\n\nimport type { COLOR_MASK_BITS, MSAA_QUALITY } from 'pixijs/constants';\nimport type { Rectangle, Matrix } from 'pixijs/math';\nimport type { IFilterTarget } from '../filters/IFilterTarget';\nimport type { Renderer } from '../Renderer';\n\nexport interface IMaskTarget extends IFilterTarget\n{\n    renderable: boolean;\n    isSprite?: boolean;\n    worldTransform: Matrix;\n    isFastRect?(): boolean;\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle;\n    render(renderer: Renderer): void;\n}\n/**\n * Component for masked elements.\n *\n * Holds mask mode and temporary data about current mask.\n * @memberof PIXI\n */\nexport class MaskData\n{\n    /** Mask type */\n    public type: MASK_TYPES;\n\n    /**\n     * Whether we know the mask type beforehand\n     * @default true\n     */\n    public autoDetect: boolean;\n\n    /**\n     * Which element we use to mask\n     * @member {PIXI.DisplayObject}\n     */\n    public maskObject: IMaskTarget;\n\n    /** Whether it belongs to MaskSystem pool */\n    public pooled: boolean;\n\n    /** Indicator of the type (always true for {@link MaskData} objects) */\n    public isMaskData: boolean;// webdoc crashes if the type is true because reasons... (will fix)\n\n    /**\n     * Resolution of the sprite mask filter.\n     * If set to `null` or `0`, the resolution of the current render target is used.\n     * @default null\n     */\n    public resolution: number;\n\n    /**\n     * Number of samples of the sprite mask filter.\n     * If set to `null`, the sample count of the current render target is used.\n     * @default PIXI.settings.FILTER_MULTISAMPLE\n     */\n    public multisample: MSAA_QUALITY;\n\n    /** If enabled is true the mask is applied, if false it will not. */\n    public enabled: boolean;\n\n    /** Color mask. */\n    public colorMask: COLOR_MASK_BITS;\n\n    /**\n     * The sprite mask filter wrapped in an array.\n     * @private\n     */\n    _filters: ISpriteMaskFilter[];\n\n    /**\n     * Stencil counter above the mask in stack\n     * @private\n     */\n    _stencilCounter: number;\n\n    /**\n     * Scissor counter above the mask in stack\n     * @private\n     */\n    _scissorCounter: number;\n\n    /**\n     * Scissor operation above the mask in stack.\n     * Null if _scissorCounter is zero, rectangle instance if positive.\n     * @private\n     */\n    _scissorRect: Rectangle;\n\n    /**\n     * pre-computed scissor rect\n     * does become _scissorRect when mask is actually pushed\n     * @private\n     */\n    _scissorRectLocal: Rectangle;\n\n    /**\n     * pre-computed color mask\n     * @private\n     */\n    _colorMask: number;\n\n    /**\n     * Targeted element. Temporary variable set by MaskSystem\n     * @member {PIXI.DisplayObject}\n     * @private\n     */\n    _target: IMaskTarget;\n\n    /**\n     * Create MaskData\n     * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask\n     */\n    constructor(maskObject: IMaskTarget = null)\n    {\n        this.type = MASK_TYPES.NONE;\n        this.autoDetect = true;\n        this.maskObject = maskObject || null;\n        this.pooled = false;\n        this.isMaskData = true;\n        this.resolution = null;\n        this.multisample = settings.FILTER_MULTISAMPLE;\n        this.enabled = true;\n        this.colorMask = 0xf;\n        this._filters = null;\n        this._stencilCounter = 0;\n        this._scissorCounter = 0;\n        this._scissorRect = null;\n        this._scissorRectLocal = null;\n        this._colorMask = 0xf;\n        this._target = null;\n    }\n\n    /**\n     * The sprite mask filter.\n     * If set to `null`, the default sprite mask filter is used.\n     * @default null\n     */\n    get filter(): ISpriteMaskFilter\n    {\n        return this._filters ? this._filters[0] : null;\n    }\n\n    set filter(value: ISpriteMaskFilter)\n    {\n        if (value)\n        {\n            if (this._filters)\n            {\n                this._filters[0] = value;\n            }\n            else\n            {\n                this._filters = [value];\n            }\n        }\n        else\n        {\n            this._filters = null;\n        }\n    }\n\n    /** Resets the mask data after popMask(). */\n    reset(): void\n    {\n        if (this.pooled)\n        {\n            this.maskObject = null;\n\n            this.type = MASK_TYPES.NONE;\n\n            this.autoDetect = true;\n        }\n\n        this._target = null;\n        this._scissorRectLocal = null;\n    }\n\n    /**\n     * Copies counters from maskData above, called from pushMask().\n     * @param maskAbove\n     */\n    copyCountersOrReset(maskAbove?: MaskData): void\n    {\n        if (maskAbove)\n        {\n            this._stencilCounter = maskAbove._stencilCounter;\n            this._scissorCounter = maskAbove._scissorCounter;\n            this._scissorRect = maskAbove._scissorRect;\n        }\n        else\n        {\n            this._stencilCounter = 0;\n            this._scissorCounter = 0;\n            this._scissorRect = null;\n        }\n    }\n}\n"],"names":["MASK_TYPES","settings"],"mappings":";;;;;;;AAwBO,MAAM,QACb,CAAA;AAAA,EA2FI,WAAA,CAAY,aAA0B,IACtC,EAAA;AACI,IAAA,IAAA,CAAK,OAAOA,oBAAW,CAAA,IAAA,CAAA;AACvB,IAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;AAClB,IAAA,IAAA,CAAK,aAAa,UAAc,IAAA,IAAA,CAAA;AAChC,IAAA,IAAA,CAAK,MAAS,GAAA,KAAA,CAAA;AACd,IAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;AAClB,IAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;AAClB,IAAA,IAAA,CAAK,cAAcC,iBAAS,CAAA,kBAAA,CAAA;AAC5B,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AACf,IAAA,IAAA,CAAK,SAAY,GAAA,EAAA,CAAA;AACjB,IAAA,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;AAChB,IAAA,IAAA,CAAK,eAAkB,GAAA,CAAA,CAAA;AACvB,IAAA,IAAA,CAAK,eAAkB,GAAA,CAAA,CAAA;AACvB,IAAA,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;AACpB,IAAA,IAAA,CAAK,iBAAoB,GAAA,IAAA,CAAA;AACzB,IAAA,IAAA,CAAK,UAAa,GAAA,EAAA,CAAA;AAClB,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AAAA,GACnB;AAAA,EAOA,IAAI,MACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,QAAA,GAAW,IAAK,CAAA,QAAA,CAAS,CAAK,CAAA,GAAA,IAAA,CAAA;AAAA,GAC9C;AAAA,EAEA,IAAI,OAAO,KACX,EAAA;AACI,IAAA,IAAI,KACJ,EAAA;AACI,MAAA,IAAI,KAAK,QACT,EAAA;AACI,QAAA,IAAA,CAAK,SAAS,CAAK,CAAA,GAAA,KAAA,CAAA;AAAA,OAGvB,MAAA;AACI,QAAK,IAAA,CAAA,QAAA,GAAW,CAAC,KAAK,CAAA,CAAA;AAAA,OAC1B;AAAA,KAGJ,MAAA;AACI,MAAA,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;AAAA,KACpB;AAAA,GACJ;AAAA,EAGA,KACA,GAAA;AACI,IAAA,IAAI,KAAK,MACT,EAAA;AACI,MAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;AAElB,MAAA,IAAA,CAAK,OAAOD,oBAAW,CAAA,IAAA,CAAA;AAEvB,MAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;AAAA,KACtB;AAEA,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AACf,IAAA,IAAA,CAAK,iBAAoB,GAAA,IAAA,CAAA;AAAA,GAC7B;AAAA,EAMA,oBAAoB,SACpB,EAAA;AACI,IAAA,IAAI,SACJ,EAAA;AACI,MAAA,IAAA,CAAK,kBAAkB,SAAU,CAAA,eAAA,CAAA;AACjC,MAAA,IAAA,CAAK,kBAAkB,SAAU,CAAA,eAAA,CAAA;AACjC,MAAA,IAAA,CAAK,eAAe,SAAU,CAAA,YAAA,CAAA;AAAA,KAGlC,MAAA;AACI,MAAA,IAAA,CAAK,eAAkB,GAAA,CAAA,CAAA;AACvB,MAAA,IAAA,CAAK,eAAkB,GAAA,CAAA,CAAA;AACvB,MAAA,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;AAAA,KACxB;AAAA,GACJ;AACJ;;;;"}