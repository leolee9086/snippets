{"version":3,"file":"generateUniformsSync.js","sources":["../../../src/shader/utils/generateUniformsSync.ts"],"sourcesContent":["import { uniformParsers } from './uniformParsers';\n\nimport type { UniformGroup } from '../UniformGroup';\nimport type { Dict } from 'pixijs/utils';\n\nexport type UniformsSyncCallback = (...args: any[]) => void;\n\n// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n// l = location\nconst GLSL_TO_SINGLE_SETTERS_CACHED: Dict<string> = {\n\n    float: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }`,\n\n    vec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n\n    vec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n\n    vec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }`,\n\n    int: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n    ivec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n    ivec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n    ivec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n\n    uint: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }`,\n    uvec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }`,\n    uvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }`,\n    uvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }`,\n\n    bool: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }`,\n    bvec2: `\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n    bvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n    bvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n\n    mat2:     'gl.uniformMatrix2fv(location, false, v)',\n    mat3:     'gl.uniformMatrix3fv(location, false, v)',\n    mat4:     'gl.uniformMatrix4fv(location, false, v)',\n\n    sampler2D: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n    samplerCube: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n    sampler2DArray: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n};\n\nconst GLSL_TO_ARRAY_SETTERS: Dict<string> = {\n\n    float:    `gl.uniform1fv(location, v)`,\n\n    vec2:     `gl.uniform2fv(location, v)`,\n    vec3:     `gl.uniform3fv(location, v)`,\n    vec4:     'gl.uniform4fv(location, v)',\n\n    mat4:     'gl.uniformMatrix4fv(location, false, v)',\n    mat3:     'gl.uniformMatrix3fv(location, false, v)',\n    mat2:     'gl.uniformMatrix2fv(location, false, v)',\n\n    int:      'gl.uniform1iv(location, v)',\n    ivec2:    'gl.uniform2iv(location, v)',\n    ivec3:    'gl.uniform3iv(location, v)',\n    ivec4:    'gl.uniform4iv(location, v)',\n\n    uint:     'gl.uniform1uiv(location, v)',\n    uvec2:    'gl.uniform2uiv(location, v)',\n    uvec3:    'gl.uniform3uiv(location, v)',\n    uvec4:    'gl.uniform4uiv(location, v)',\n\n    bool:     'gl.uniform1iv(location, v)',\n    bvec2:    'gl.uniform2iv(location, v)',\n    bvec3:    'gl.uniform3iv(location, v)',\n    bvec4:    'gl.uniform4iv(location, v)',\n\n    sampler2D:      'gl.uniform1iv(location, v)',\n    samplerCube:    'gl.uniform1iv(location, v)',\n    sampler2DArray: 'gl.uniform1iv(location, v)',\n};\n\nexport function generateUniformsSync(group: UniformGroup, uniformData: Dict<any>): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    `];\n\n    for (const i in group.uniforms)\n    {\n        const data = uniformData[i];\n\n        if (!data)\n        {\n            if (group.uniforms[i]?.group)\n            {\n                if (group.uniforms[i].ubo)\n                {\n                    funcFragments.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        renderer.shader.syncUniformGroup(uv.${i}, syncData);\n                    `);\n                }\n            }\n\n            continue;\n        }\n\n        const uniform = group.uniforms[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            if (uniformParsers[j].test(data, uniform))\n            {\n                funcFragments.push(uniformParsers[j].code(i, uniform));\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;\n            const template = templateType[data.type].replace('location', `ud[\"${i}\"].location`);\n\n            funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n        }\n    }\n\n    /*\n     * the introduction of syncData is to solve an issue where textures in uniform groups are not set correctly\n     * the texture count was always starting from 0 in each group. This needs to increment each time a texture is used\n     * no matter which group is being used\n     *\n     */\n    // eslint-disable-next-line no-new-func\n    return new Function('ud', 'uv', 'renderer', 'syncData', funcFragments.join('\\n')) as UniformsSyncCallback;\n}\n"],"names":["uniformParsers"],"mappings":";;;;;;AAaA,MAAM,6BAA8C,GAAA;AAAA,EAEhD,KAAO,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAOP,IAAM,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EASN,IAAM,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAUN,IAAM,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAWN,GAAK,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAOL,KAAO,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAQP,KAAO,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EASP,KAAO,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAWP,IAAM,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAON,KAAO,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAQP,KAAO,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EASP,KAAO,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAWP,IAAM,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAMN,KAAO,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAQP,KAAO,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EASP,KAAO,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAWP,IAAU,EAAA,yCAAA;AAAA,EACV,IAAU,EAAA,yCAAA;AAAA,EACV,IAAU,EAAA,yCAAA;AAAA,EAEV,SAAW,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAOX,WAAa,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAAA,EAOb,cAAgB,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAA,CAAA;AAOpB,CAAA,CAAA;AAEA,MAAM,qBAAsC,GAAA;AAAA,EAExC,KAAU,EAAA,CAAA,0BAAA,CAAA;AAAA,EAEV,IAAU,EAAA,CAAA,0BAAA,CAAA;AAAA,EACV,IAAU,EAAA,CAAA,0BAAA,CAAA;AAAA,EACV,IAAU,EAAA,4BAAA;AAAA,EAEV,IAAU,EAAA,yCAAA;AAAA,EACV,IAAU,EAAA,yCAAA;AAAA,EACV,IAAU,EAAA,yCAAA;AAAA,EAEV,GAAU,EAAA,4BAAA;AAAA,EACV,KAAU,EAAA,4BAAA;AAAA,EACV,KAAU,EAAA,4BAAA;AAAA,EACV,KAAU,EAAA,4BAAA;AAAA,EAEV,IAAU,EAAA,6BAAA;AAAA,EACV,KAAU,EAAA,6BAAA;AAAA,EACV,KAAU,EAAA,6BAAA;AAAA,EACV,KAAU,EAAA,6BAAA;AAAA,EAEV,IAAU,EAAA,4BAAA;AAAA,EACV,KAAU,EAAA,4BAAA;AAAA,EACV,KAAU,EAAA,4BAAA;AAAA,EACV,KAAU,EAAA,4BAAA;AAAA,EAEV,SAAgB,EAAA,4BAAA;AAAA,EAChB,WAAgB,EAAA,4BAAA;AAAA,EAChB,cAAgB,EAAA,4BAAA;AACpB,CAAA,CAAA;AAEO,SAAA,oBAAA,CAA8B,OAAqB,WAC1D,EAAA;AACI,EAAA,MAAM,gBAAgB,CAAC,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMtB,CAAA,CAAA,CAAA;AAED,EAAW,KAAA,MAAA,CAAA,IAAK,MAAM,QACtB,EAAA;AACI,IAAA,MAAM,OAAO,WAAY,CAAA,CAAA,CAAA,CAAA;AAEzB,IAAA,IAAI,CAAC,IACL,EAAA;AACI,MAAI,IAAA,KAAA,CAAM,QAAS,CAAA,CAAA,CAAA,EAAI,KACvB,EAAA;AACI,QAAI,IAAA,KAAA,CAAM,QAAS,CAAA,CAAA,CAAA,CAAG,GACtB,EAAA;AACI,UAAA,aAAA,CAAc,IAAK,CAAA,CAAA;AAAA,kEAAA,EAC6B,CAAO,CAAA,GAAA,EAAA,CAAA,CAAA;AAAA,oBACtD,CAAA,CAAA,CAAA;AAAA,SAGL,MAAA;AACI,UAAA,aAAA,CAAc,IAAK,CAAA,CAAA;AAAA,4DACuB,EAAA,CAAA,CAAA;AAAA,oBACzC,CAAA,CAAA,CAAA;AAAA,SACL;AAAA,OACJ;AAEA,MAAA,SAAA;AAAA,KACJ;AAEA,IAAM,MAAA,OAAA,GAAU,MAAM,QAAS,CAAA,CAAA,CAAA,CAAA;AAE/B,IAAA,IAAI,MAAS,GAAA,KAAA,CAAA;AAEb,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAAA,6BAAA,CAAe,QAAQ,CAC3C,EAAA,EAAA;AACI,MAAA,IAAIA,6BAAe,CAAA,CAAA,CAAA,CAAG,IAAK,CAAA,IAAA,EAAM,OAAO,CACxC,EAAA;AACI,QAAA,aAAA,CAAc,KAAKA,6BAAe,CAAA,CAAA,CAAA,CAAG,IAAK,CAAA,CAAA,EAAG,OAAO,CAAC,CAAA,CAAA;AACrD,QAAS,MAAA,GAAA,IAAA,CAAA;AAET,QAAA,MAAA;AAAA,OACJ;AAAA,KACJ;AAEA,IAAA,IAAI,CAAC,MACL,EAAA;AACI,MAAA,MAAM,eAAe,IAAK,CAAA,IAAA,KAAS,KAAK,CAAC,IAAA,CAAK,UAAU,6BAAgC,GAAA,qBAAA,CAAA;AACxF,MAAA,MAAM,WAAW,YAAa,CAAA,IAAA,CAAK,MAAM,OAAQ,CAAA,UAAA,EAAY,OAAO,CAAc,CAAA,WAAA,CAAA,CAAA,CAAA;AAElF,MAAA,aAAA,CAAc,IAAK,CAAA,CAAA;AAAA,qBACR,EAAA,CAAA,CAAA;AAAA;AAAA,oBAED,EAAA,CAAA,CAAA;AAAA,YAAA,EACR,QAAW,CAAA,CAAA,CAAA,CAAA,CAAA;AAAA,KACjB;AAAA,GACJ;AASA,EAAO,OAAA,IAAI,SAAS,IAAM,EAAA,IAAA,EAAM,YAAY,UAAY,EAAA,aAAA,CAAc,IAAK,CAAA,IAAI,CAAC,CAAA,CAAA;AACpF;;;;"}