{"version":3,"file":"DisplayObject.js","sources":["../src/DisplayObject.ts"],"sourcesContent":["import { DEG_TO_RAD, RAD_TO_DEG, Rectangle, Transform, utils } from 'pixijs/core';\nimport { Bounds } from './Bounds';\n\nimport type { Filter, IPointData, Matrix, MaskData, ObservablePoint, Point, Renderer } from 'pixijs/core';\nimport type { Container } from './Container';\n\nexport interface IDestroyOptions\n{\n    children?: boolean;\n    texture?: boolean;\n    baseTexture?: boolean;\n}\n\nexport interface DisplayObjectEvents extends GlobalMixins.DisplayObjectEvents\n{\n    added: [container: Container];\n    childAdded: [child: DisplayObject, container: Container, index: number];\n    childRemoved: [child: DisplayObject, container: Container, index: number];\n    destroyed: [];\n    removed: [container: Container];\n}\n\nexport interface DisplayObject\n    extends Omit<GlobalMixins.DisplayObject, keyof utils.EventEmitter<DisplayObjectEvents>>,\n    utils.EventEmitter<DisplayObjectEvents> {}\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * This is an abstract class and can not be used on its own; rather it should be extended.\n *\n * ## Display objects implemented in PixiJS\n *\n * | Display Object                  | Description                                                           |\n * | ------------------------------- | --------------------------------------------------------------------- |\n * | {@link PIXI.Container}          | Adds support for `children` to DisplayObject                          |\n * | {@link PIXI.Graphics}           | Shape-drawing display object similar to the Canvas API                |\n * | {@link PIXI.Sprite}             | Draws textures (i.e. images)                                          |\n * | {@link PIXI.Text}               | Draws text using the Canvas API internally                            |\n * | {@link PIXI.BitmapText}         | More scaleable solution for text rendering, reusing glyph textures    |\n * | {@link PIXI.TilingSprite}       | Draws textures/images in a tiled fashion                              |\n * | {@link PIXI.AnimatedSprite}     | Draws an animation of multiple images                                 |\n * | {@link PIXI.Mesh}               | Provides a lower-level API for drawing meshes with custom data        |\n * | {@link PIXI.NineSlicePlane}     | Mesh-related                                                          |\n * | {@link PIXI.SimpleMesh}         | v4-compatible mesh                                                    |\n * | {@link PIXI.SimplePlane}        | Mesh-related                                                          |\n * | {@link PIXI.SimpleRope}         | Mesh-related                                                          |\n *\n * ## Transforms\n *\n * The [transform]{@link DisplayObject#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link PIXI.DisplayObject#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link PIXI.DisplayObject#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link PIXI.DisplayObject#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link PIXI.DisplayObject#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link PIXI.DisplayObject#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link PIXI.DisplayObject#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link PIXI.DisplayObject#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are communtative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>angle</td>\n *       <td>Rotation. This is an alias for [rotation]{@link PIXI.DisplayObject#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>x</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>y</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>width</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>height</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n *\n * ## Bounds\n *\n * The bounds of a display object is defined by the minimum axis-aligned rectangle in world space that can fit\n * around it. The abstract `calculateBounds` method is responsible for providing it (and it should use the\n * `worldTransform` to calculate in world space).\n *\n * There are a few additional types of bounding boxes:\n *\n * | Bounds                | Description                                                                              |\n * | --------------------- | ---------------------------------------------------------------------------------------- |\n * | World Bounds          | This is synonymous is the regular bounds described above. See `getBounds()`.             |\n * | Local Bounds          | This the axis-aligned bounding box in the parent's local space. See `getLocalBounds()`.  |\n * | Render Bounds         | The bounds, but including extra rendering effects like filter padding.                   |\n * | Projected Bounds      | The bounds of the projected display object onto the screen. Usually equals world bounds. |\n * | Relative Bounds       | The bounds of a display object when projected onto a ancestor's (or parent's) space.     |\n * | Natural Bounds        | The bounds of an object in its own local space (not parent's space, like in local bounds)|\n * | Content Bounds        | The natural bounds when excluding all children of a `Container`.                         |\n *\n * ### calculateBounds\n *\n * [Container]{@link Container} already implements `calculateBounds` in a manner that includes children.\n *\n * But for a non-Container display object, the `calculateBounds` method must be overridden in order for `getBounds` and\n * `getLocalBounds` to work. This method must write the bounds into `this._bounds`.\n *\n * Generally, the following technique works for most simple cases: take the list of points\n * forming the \"hull\" of the object (i.e. outline of the object's shape), and then add them\n * using {@link PIXI.Bounds#addPointMatrix}.\n *\n * ```js\n * calculateBounds()\n * {\n *     const points = [...];\n *\n *     for (let i = 0, j = points.length; i < j; i++)\n *     {\n *         this._bounds.addPointMatrix(this.worldTransform, points[i]);\n *     }\n * }\n * ```\n *\n * You can optimize this for a large number of points by using {@link PIXI.Bounds#addVerticesMatrix} to pass them\n * in one array together.\n *\n * ## Alpha\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n *\n * The alpha with which the display object will be rendered is called the [worldAlpha]{@link PIXI.DisplayObject#worldAlpha}.\n *\n * ## Renderable vs Visible\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n *\n * It is recommended that applications use the `renderable` property for culling. See\n * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} or\n * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull} for more details.\n *\n * Otherwise, to prevent an object from rendering in the general-purpose sense - `visible` is the property to use. This\n * one is also better in terms of performance.\n * @memberof PIXI\n */\nexport abstract class DisplayObject extends utils.EventEmitter<DisplayObjectEvents>\n{\n    abstract sortDirty: boolean;\n\n    /** The display object container that contains this display object. */\n    public parent: Container;\n\n    /**\n     * The multiplied alpha of the displayObject.\n     * @readonly\n     */\n    public worldAlpha: number;\n\n    /**\n     * World transform and local transform of this object.\n     * This will become read-only later, please do not assign anything there unless you know what are you doing.\n     */\n    public transform: Transform;\n\n    /** The opacity of the object. */\n    public alpha: number;\n\n    /**\n     * The visibility of the object. If false the object will not be drawn, and\n     * the updateTransform function will not be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.\n     */\n    public visible: boolean;\n\n    /**\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\n     * methods will still be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds manually.\n     */\n    public renderable: boolean;\n\n    /**\n     * Should this object be rendered if the bounds of this object are out of frame?\n     *\n     * Culling has no effect on whether updateTransform is called.\n     */\n    public cullable: boolean;\n\n    /**\n     * If set, this shape is used for culling instead of the bounds of this object.\n     * It can improve the culling performance of objects with many children.\n     * The culling area is defined in local space.\n     */\n    public cullArea: Rectangle;\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     */\n    public filterArea: Rectangle;\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     */\n    public filters: Filter[] | null;\n\n    /** Used to fast check if a sprite is.. a sprite! */\n    public isSprite: boolean;\n\n    /** Does any other displayObject use this object as a mask? */\n    public isMask: boolean;\n\n    /**\n     * Which index in the children array the display component was before the previous zIndex sort.\n     * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.\n     * @protected\n     */\n    public _lastSortedIndex: number;\n\n    /**\n     * The original, cached mask of the object.\n     * @protected\n     */\n    public _mask: Container | MaskData;\n\n    /** The bounds object, this is used to calculate and store the bounds of the displayObject. */\n    public _bounds: Bounds;\n\n    /** Local bounds object, swapped with `_bounds` when using `getLocalBounds()`. */\n    public _localBounds: Bounds;\n\n    /**\n     * The zIndex of the displayObject.\n     * A higher value will mean it will be rendered on top of other displayObjects within the same container.\n     * @protected\n     */\n    protected _zIndex: number;\n\n    /**\n     * Currently enabled filters.\n     * @protected\n     */\n    protected _enabledFilters: Filter[];\n\n    /** Flags the cached bounds as dirty. */\n    protected _boundsID: number;\n\n    /** Cache of this display-object's bounds-rectangle. */\n    protected _boundsRect: Rectangle;\n\n    /** Cache of this display-object's local-bounds rectangle. */\n    protected _localBoundsRect: Rectangle;\n\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    protected _destroyed: boolean;\n\n    /** The number of times this object is used as a mask by another object. */\n    private _maskRefCount: number;\n    private tempDisplayObjectParent: TemporaryDisplayObject;\n    public displayObjectUpdateTransform: () => void;\n\n    /**\n     * Mixes all enumerable properties and methods from a source object to DisplayObject.\n     * @param source - The source of properties and methods to mix in.\n     */\n    static mixin(source: utils.Dict<any>): void\n    {\n        // in ES8/ES2017, this would be really easy:\n        // Object.defineProperties(DisplayObject.prototype, Object.getOwnPropertyDescriptors(source));\n\n        // get all the enumerable property keys\n        const keys = Object.keys(source);\n\n        // loop through properties\n        for (let i = 0; i < keys.length; ++i)\n        {\n            const propertyName = keys[i];\n\n            // Set the property using the property descriptor - this works for accessors and normal value properties\n            Object.defineProperty(\n                DisplayObject.prototype,\n                propertyName,\n                Object.getOwnPropertyDescriptor(source, propertyName)\n            );\n        }\n    }\n\n    constructor()\n    {\n        super();\n\n        this.tempDisplayObjectParent = null;\n\n        // TODO: need to create Transform from factory\n        this.transform = new Transform();\n        this.alpha = 1;\n        this.visible = true;\n        this.renderable = true;\n        this.cullable = false;\n        this.cullArea = null;\n\n        this.parent = null;\n        this.worldAlpha = 1;\n\n        this._lastSortedIndex = 0;\n        this._zIndex = 0;\n\n        this.filterArea = null;\n        this.filters = null;\n        this._enabledFilters = null;\n\n        this._bounds = new Bounds();\n        this._localBounds = null;\n        this._boundsID = 0;\n        this._boundsRect = null;\n        this._localBoundsRect = null;\n        this._mask = null;\n        this._maskRefCount = 0;\n        this._destroyed = false;\n\n        this.isSprite = false;\n        this.isMask = false;\n    }\n\n    /**\n     * Fired when this DisplayObject is added to a Container.\n     * @instance\n     * @event added\n     * @param {PIXI.Container} container - The container added to.\n     */\n\n    /**\n     * Fired when this DisplayObject is removed from a Container.\n     * @instance\n     * @event removed\n     * @param {PIXI.Container} container - The container removed from.\n     */\n\n    /**\n     * Fired when this DisplayObject is destroyed. This event is emitted once\n     * destroy is finished.\n     * @instance\n     * @event destroyed\n     */\n\n    /** Readonly flag for destroyed display objects. */\n    get destroyed(): boolean\n    {\n        return this._destroyed;\n    }\n\n    /** Recalculates the bounds of the display object. */\n    abstract calculateBounds(): void;\n\n    abstract removeChild(child: DisplayObject): void;\n\n    /**\n     * Renders the object using the WebGL renderer.\n     * @param renderer - The renderer.\n     */\n    abstract render(renderer: Renderer): void;\n\n    /** Recursively updates transform of all objects from the root to this one internal function for toLocal() */\n    protected _recursivePostUpdateTransform(): void\n    {\n        if (this.parent)\n        {\n            this.parent._recursivePostUpdateTransform();\n            this.transform.updateTransform(this.parent.transform);\n        }\n        else\n        {\n            this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n        }\n    }\n\n    /** Updates the object transform for rendering. TODO - Optimization pass! */\n    updateTransform(): void\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n        // multiply the alphas..\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    }\n\n    /**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.\n     *\n     * This method is expensive on containers with a large subtree (like the stage). This is because the bounds\n     * of a container depend on its children's bounds, which recursively causes all bounds in the subtree to\n     * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update\n     * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using\n     * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,\n     * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as\n     * its height increases.\n     *\n     * The transforms of all objects in a container's **subtree** and of all **ancestors** are updated.\n     * The world bounds of all display objects in a container's **subtree** will also be recalculated.\n     *\n     * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds\n     * calculation if needed.\n     *\n     * ```js\n     * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);\n     * ```\n     *\n     * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This\n     * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more\n     * details.\n     *\n     * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms\n     * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain\n     * cases.\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n     */\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle\n    {\n        if (!skipUpdate)\n        {\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.updateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this._recursivePostUpdateTransform();\n                this.updateTransform();\n            }\n        }\n\n        if (this._bounds.updateID !== this._boundsID)\n        {\n            this.calculateBounds();\n            this._bounds.updateID = this._boundsID;\n        }\n\n        if (!rect)\n        {\n            if (!this._boundsRect)\n            {\n                this._boundsRect = new Rectangle();\n            }\n\n            rect = this._boundsRect;\n        }\n\n        return this._bounds.getRectangle(rect);\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @returns - The rectangular bounding area.\n     */\n    getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        if (!rect)\n        {\n            if (!this._localBoundsRect)\n            {\n                this._localBoundsRect = new Rectangle();\n            }\n\n            rect = this._localBoundsRect;\n        }\n\n        if (!this._localBounds)\n        {\n            this._localBounds = new Bounds();\n        }\n\n        const transformRef = this.transform;\n        const parentRef = this.parent;\n\n        this.parent = null;\n        this.transform = this._tempDisplayObjectParent.transform;\n\n        const worldBounds = this._bounds;\n        const worldBoundsID = this._boundsID;\n\n        this._bounds = this._localBounds;\n\n        const bounds = this.getBounds(false, rect);\n\n        this.parent = parentRef;\n        this.transform = transformRef;\n\n        this._bounds = worldBounds;\n        this._bounds.updateID += this._boundsID - worldBoundsID;// reflect side-effects\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the global position of the display object.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     */\n    toGlobal<P extends IPointData = Point>(position: IPointData, point?: P, skipUpdate = false): P\n    {\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // don't need to update the lot\n        return this.worldTransform.apply<P>(position, point);\n    }\n\n    /**\n     * Calculates the local position of the display object relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The DisplayObject to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     */\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse<P>(position, point);\n    }\n\n    /**\n     * Set the parent Container of this DisplayObject.\n     * @param container - The Container to add this DisplayObject to.\n     * @returns - The Container that this DisplayObject was added to.\n     */\n    setParent(container: Container): Container\n    {\n        if (!container || !container.addChild)\n        {\n            throw new Error('setParent: Argument must be a Container');\n        }\n\n        container.addChild(this);\n\n        return container;\n    }\n\n    /** Remove the DisplayObject from its parent Container. If the DisplayObject has no parent, do nothing. */\n    removeFromParent()\n    {\n        this.parent?.removeChild(this);\n    }\n\n    /**\n     * Convenience function to set the position, scale, skew and pivot at once.\n     * @param x - The X position\n     * @param y - The Y position\n     * @param scaleX - The X scale value\n     * @param scaleY - The Y scale value\n     * @param rotation - The rotation\n     * @param skewX - The X skew value\n     * @param skewY - The Y skew value\n     * @param pivotX - The X pivot value\n     * @param pivotY - The Y pivot value\n     * @returns - The DisplayObject instance\n     */\n    setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0): this\n    {\n        this.position.x = x;\n        this.position.y = y;\n        this.scale.x = !scaleX ? 1 : scaleX;\n        this.scale.y = !scaleY ? 1 : scaleY;\n        this.rotation = rotation;\n        this.skew.x = skewX;\n        this.skew.y = skewY;\n        this.pivot.x = pivotX;\n        this.pivot.y = pivotY;\n\n        return this;\n    }\n\n    /**\n     * Base destroy method for generic display objects. This will automatically\n     * remove the display object from its parent Container as well as remove\n     * all current event listeners and internal references. Do not use a DisplayObject\n     * after calling `destroy()`.\n     * @param _options\n     */\n    destroy(_options?: IDestroyOptions | boolean): void\n    {\n        this.removeFromParent();\n\n        this._destroyed = true;\n        this.transform = null;\n\n        this.parent = null;\n        this._bounds = null;\n        this.mask = null;\n\n        this.cullArea = null;\n        this.filters = null;\n        this.filterArea = null;\n        this.hitArea = null;\n\n        this.interactive = false;\n        this.interactiveChildren = false;\n\n        this.emit('destroyed');\n        this.removeAllListeners();\n    }\n\n    /**\n     * @protected\n     * @member {PIXI.Container}\n     */\n    get _tempDisplayObjectParent(): TemporaryDisplayObject\n    {\n        if (this.tempDisplayObjectParent === null)\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            this.tempDisplayObjectParent = new TemporaryDisplayObject();\n        }\n\n        return this.tempDisplayObjectParent;\n    }\n\n    /**\n     * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root.\n     *\n     * ```js\n     * const cacheParent = elem.enableTempParent();\n     * elem.updateTransform();\n     * elem.disableTempParent(cacheParent);\n     * ```\n     * @returns - Current parent\n     */\n    enableTempParent(): Container\n    {\n        const myParent = this.parent;\n\n        this.parent = this._tempDisplayObjectParent as Container;\n\n        return myParent;\n    }\n\n    /**\n     * Pair method for `enableTempParent`\n     * @param cacheParent - Actual parent of element\n     */\n    disableTempParent(cacheParent: Container): void\n    {\n        this.parent = cacheParent;\n    }\n\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get x(): number\n    {\n        return this.position.x;\n    }\n\n    set x(value: number)\n    {\n        this.transform.position.x = value;\n    }\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get y(): number\n    {\n        return this.position.y;\n    }\n\n    set y(value: number)\n    {\n        this.transform.position.y = value;\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     * @readonly\n     */\n    get worldTransform(): Matrix\n    {\n        return this.transform.worldTransform;\n    }\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    get localTransform(): Matrix\n    {\n        return this.transform.localTransform;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this.transform.position;\n    }\n\n    set position(value: IPointData)\n    {\n        this.transform.position.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        return this.transform.scale;\n    }\n\n    set scale(value: IPointData)\n    {\n        this.transform.scale.copyFrom(value);\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        return this.transform.pivot;\n    }\n\n    set pivot(value: IPointData)\n    {\n        this.transform.pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * @since 4.0.0\n     */\n    get skew(): ObservablePoint\n    {\n        return this.transform.skew;\n    }\n\n    set skew(value: IPointData)\n    {\n        this.transform.skew.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get rotation(): number\n    {\n        return this.transform.rotation;\n    }\n\n    set rotation(value: number)\n    {\n        this.transform.rotation = value;\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get angle(): number\n    {\n        return this.transform.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.transform.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The zIndex of the displayObject.\n     *\n     * If a container has the sortableChildren property set to true, children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other display objects within the same container.\n     * @see PIXI.Container#sortableChildren\n     */\n    get zIndex(): number\n    {\n        return this._zIndex;\n    }\n\n    set zIndex(value: number)\n    {\n        this._zIndex = value;\n        if (this.parent)\n        {\n            this.parent.sortDirty = true;\n        }\n    }\n\n    /**\n     * Indicates if the object is globally visible.\n     * @readonly\n     */\n    get worldVisible(): boolean\n    {\n        let item = this as DisplayObject;\n\n        do\n        {\n            if (!item.visible)\n            {\n                return false;\n            }\n\n            item = item.parent;\n        } while (item);\n\n        return true;\n    }\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * import { Graphics, Sprite } from 'pixijs/browser';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     * @todo At the moment, CanvasRenderer doesn't support Sprite as mask.\n     */\n    get mask(): Container | MaskData | null\n    {\n        return this._mask;\n    }\n\n    set mask(value: Container | MaskData | null)\n    {\n        if (this._mask === value)\n        {\n            return;\n        }\n\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).isMaskData\n                ? (this._mask as MaskData).maskObject : this._mask) as Container;\n\n            if (maskObject)\n            {\n                maskObject._maskRefCount--;\n\n                if (maskObject._maskRefCount === 0)\n                {\n                    maskObject.renderable = true;\n                    maskObject.isMask = false;\n                }\n            }\n        }\n\n        this._mask = value;\n\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).isMaskData\n                ? (this._mask as MaskData).maskObject : this._mask) as Container;\n\n            if (maskObject)\n            {\n                if (maskObject._maskRefCount === 0)\n                {\n                    maskObject.renderable = false;\n                    maskObject.isMask = true;\n                }\n\n                maskObject._maskRefCount++;\n            }\n        }\n    }\n}\n\n/**\n * @private\n */\nexport class TemporaryDisplayObject extends DisplayObject\n{\n    calculateBounds: () => null;\n    removeChild: (child: DisplayObject) => null;\n    render: (renderer: Renderer) => null;\n    sortDirty: boolean = null;\n}\n\n/**\n * DisplayObject default updateTransform, does not update children of container.\n * Will crash if there's no parent element.\n * @memberof PIXI.DisplayObject#\n * @method displayObjectUpdateTransform\n */\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n"],"names":["utils","Transform","Bounds","Rectangle","RAD_TO_DEG","DEG_TO_RAD"],"mappings":";;;;;;;AAmNsB,MAAA,aAAA,SAAsBA,WAAM,YAClD,CAAA;AAAA,EAmJI,WACA,GAAA;AACI,IAAM,KAAA,EAAA,CAAA;AAEN,IAAA,IAAA,CAAK,uBAA0B,GAAA,IAAA,CAAA;AAG/B,IAAK,IAAA,CAAA,SAAA,GAAY,IAAIC,cAAU,EAAA,CAAA;AAC/B,IAAA,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA;AACb,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AACf,IAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;AAClB,IAAA,IAAA,CAAK,QAAW,GAAA,KAAA,CAAA;AAChB,IAAA,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;AAEhB,IAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;AACd,IAAA,IAAA,CAAK,UAAa,GAAA,CAAA,CAAA;AAElB,IAAA,IAAA,CAAK,gBAAmB,GAAA,CAAA,CAAA;AACxB,IAAA,IAAA,CAAK,OAAU,GAAA,CAAA,CAAA;AAEf,IAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;AAClB,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AACf,IAAA,IAAA,CAAK,eAAkB,GAAA,IAAA,CAAA;AAEvB,IAAK,IAAA,CAAA,OAAA,GAAU,IAAIC,aAAO,EAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;AACpB,IAAA,IAAA,CAAK,SAAY,GAAA,CAAA,CAAA;AACjB,IAAA,IAAA,CAAK,WAAc,GAAA,IAAA,CAAA;AACnB,IAAA,IAAA,CAAK,gBAAmB,GAAA,IAAA,CAAA;AACxB,IAAA,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;AACb,IAAA,IAAA,CAAK,aAAgB,GAAA,CAAA,CAAA;AACrB,IAAA,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;AAElB,IAAA,IAAA,CAAK,QAAW,GAAA,KAAA,CAAA;AAChB,IAAA,IAAA,CAAK,MAAS,GAAA,KAAA,CAAA;AAAA,GAClB;AAAA,EAzDA,OAAO,MAAM,MACb,EAAA;AAKI,IAAM,MAAA,IAAA,GAAO,MAAO,CAAA,IAAA,CAAK,MAAM,CAAA,CAAA;AAG/B,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,MAAA,EAAQ,EAAE,CACnC,EAAA;AACI,MAAA,MAAM,eAAe,IAAK,CAAA,CAAA,CAAA,CAAA;AAG1B,MAAO,MAAA,CAAA,cAAA,CACH,cAAc,SACd,EAAA,YAAA,EACA,OAAO,wBAAyB,CAAA,MAAA,EAAQ,YAAY,CACxD,CAAA,CAAA;AAAA,KACJ;AAAA,GACJ;AAAA,EA6DA,IAAI,SACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,UAAA,CAAA;AAAA,GAChB;AAAA,EAcA,6BACA,GAAA;AACI,IAAA,IAAI,KAAK,MACT,EAAA;AACI,MAAA,IAAA,CAAK,OAAO,6BAA8B,EAAA,CAAA;AAC1C,MAAA,IAAA,CAAK,SAAU,CAAA,eAAA,CAAgB,IAAK,CAAA,MAAA,CAAO,SAAS,CAAA,CAAA;AAAA,KAGxD,MAAA;AACI,MAAA,IAAA,CAAK,SAAU,CAAA,eAAA,CAAgB,IAAK,CAAA,wBAAA,CAAyB,SAAS,CAAA,CAAA;AAAA,KAC1E;AAAA,GACJ;AAAA,EAGA,eACA,GAAA;AACI,IAAK,IAAA,CAAA,SAAA,EAAA,CAAA;AAEL,IAAA,IAAA,CAAK,SAAU,CAAA,eAAA,CAAgB,IAAK,CAAA,MAAA,CAAO,SAAS,CAAA,CAAA;AAEpD,IAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAK,MAAO,CAAA,UAAA,CAAA;AAAA,GAC/C;AAAA,EAoCA,SAAA,CAAU,YAAsB,IAChC,EAAA;AACI,IAAA,IAAI,CAAC,UACL,EAAA;AACI,MAAI,IAAA,CAAC,KAAK,MACV,EAAA;AACI,QAAA,IAAA,CAAK,SAAS,IAAK,CAAA,wBAAA,CAAA;AACnB,QAAA,IAAA,CAAK,eAAgB,EAAA,CAAA;AACrB,QAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;AAAA,OAGlB,MAAA;AACI,QAAA,IAAA,CAAK,6BAA8B,EAAA,CAAA;AACnC,QAAA,IAAA,CAAK,eAAgB,EAAA,CAAA;AAAA,OACzB;AAAA,KACJ;AAEA,IAAA,IAAI,IAAK,CAAA,OAAA,CAAQ,QAAa,KAAA,IAAA,CAAK,SACnC,EAAA;AACI,MAAA,IAAA,CAAK,eAAgB,EAAA,CAAA;AACrB,MAAK,IAAA,CAAA,OAAA,CAAQ,WAAW,IAAK,CAAA,SAAA,CAAA;AAAA,KACjC;AAEA,IAAA,IAAI,CAAC,IACL,EAAA;AACI,MAAI,IAAA,CAAC,KAAK,WACV,EAAA;AACI,QAAK,IAAA,CAAA,WAAA,GAAc,IAAIC,cAAU,EAAA,CAAA;AAAA,OACrC;AAEA,MAAA,IAAA,GAAO,IAAK,CAAA,WAAA,CAAA;AAAA,KAChB;AAEA,IAAO,OAAA,IAAA,CAAK,OAAQ,CAAA,YAAA,CAAa,IAAI,CAAA,CAAA;AAAA,GACzC;AAAA,EAOA,eAAe,IACf,EAAA;AACI,IAAA,IAAI,CAAC,IACL,EAAA;AACI,MAAI,IAAA,CAAC,KAAK,gBACV,EAAA;AACI,QAAK,IAAA,CAAA,gBAAA,GAAmB,IAAIA,cAAU,EAAA,CAAA;AAAA,OAC1C;AAEA,MAAA,IAAA,GAAO,IAAK,CAAA,gBAAA,CAAA;AAAA,KAChB;AAEA,IAAI,IAAA,CAAC,KAAK,YACV,EAAA;AACI,MAAK,IAAA,CAAA,YAAA,GAAe,IAAID,aAAO,EAAA,CAAA;AAAA,KACnC;AAEA,IAAA,MAAM,eAAe,IAAK,CAAA,SAAA,CAAA;AAC1B,IAAA,MAAM,YAAY,IAAK,CAAA,MAAA,CAAA;AAEvB,IAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;AACd,IAAK,IAAA,CAAA,SAAA,GAAY,KAAK,wBAAyB,CAAA,SAAA,CAAA;AAE/C,IAAA,MAAM,cAAc,IAAK,CAAA,OAAA,CAAA;AACzB,IAAA,MAAM,gBAAgB,IAAK,CAAA,SAAA,CAAA;AAE3B,IAAA,IAAA,CAAK,UAAU,IAAK,CAAA,YAAA,CAAA;AAEpB,IAAA,MAAM,MAAS,GAAA,IAAA,CAAK,SAAU,CAAA,KAAA,EAAO,IAAI,CAAA,CAAA;AAEzC,IAAA,IAAA,CAAK,MAAS,GAAA,SAAA,CAAA;AACd,IAAA,IAAA,CAAK,SAAY,GAAA,YAAA,CAAA;AAEjB,IAAA,IAAA,CAAK,OAAU,GAAA,WAAA,CAAA;AACf,IAAK,IAAA,CAAA,OAAA,CAAQ,QAAY,IAAA,IAAA,CAAK,SAAY,GAAA,aAAA,CAAA;AAE1C,IAAO,OAAA,MAAA,CAAA;AAAA,GACX;AAAA,EAUA,QAAuC,CAAA,QAAA,EAAsB,KAAW,EAAA,UAAA,GAAa,KACrF,EAAA;AACI,IAAA,IAAI,CAAC,UACL,EAAA;AACI,MAAA,IAAA,CAAK,6BAA8B,EAAA,CAAA;AAKnC,MAAI,IAAA,CAAC,KAAK,MACV,EAAA;AACI,QAAA,IAAA,CAAK,SAAS,IAAK,CAAA,wBAAA,CAAA;AACnB,QAAA,IAAA,CAAK,4BAA6B,EAAA,CAAA;AAClC,QAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;AAAA,OAGlB,MAAA;AACI,QAAA,IAAA,CAAK,4BAA6B,EAAA,CAAA;AAAA,OACtC;AAAA,KACJ;AAGA,IAAA,OAAO,IAAK,CAAA,cAAA,CAAe,KAAS,CAAA,QAAA,EAAU,KAAK,CAAA,CAAA;AAAA,GACvD;AAAA,EAWA,OAAsC,CAAA,QAAA,EAAsB,IAAsB,EAAA,KAAA,EAAW,UAC7F,EAAA;AACI,IAAA,IAAI,IACJ,EAAA;AACI,MAAA,QAAA,GAAW,IAAK,CAAA,QAAA,CAAS,QAAU,EAAA,KAAA,EAAO,UAAU,CAAA,CAAA;AAAA,KACxD;AAEA,IAAA,IAAI,CAAC,UACL,EAAA;AACI,MAAA,IAAA,CAAK,6BAA8B,EAAA,CAAA;AAKnC,MAAI,IAAA,CAAC,KAAK,MACV,EAAA;AACI,QAAA,IAAA,CAAK,SAAS,IAAK,CAAA,wBAAA,CAAA;AACnB,QAAA,IAAA,CAAK,4BAA6B,EAAA,CAAA;AAClC,QAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;AAAA,OAGlB,MAAA;AACI,QAAA,IAAA,CAAK,4BAA6B,EAAA,CAAA;AAAA,OACtC;AAAA,KACJ;AAGA,IAAA,OAAO,IAAK,CAAA,cAAA,CAAe,YAAgB,CAAA,QAAA,EAAU,KAAK,CAAA,CAAA;AAAA,GAC9D;AAAA,EAOA,UAAU,SACV,EAAA;AACI,IAAA,IAAI,CAAC,SAAA,IAAa,CAAC,SAAA,CAAU,QAC7B,EAAA;AACI,MAAM,MAAA,IAAI,MAAM,yCAAyC,CAAA,CAAA;AAAA,KAC7D;AAEA,IAAA,SAAA,CAAU,SAAS,IAAI,CAAA,CAAA;AAEvB,IAAO,OAAA,SAAA,CAAA;AAAA,GACX;AAAA,EAGA,gBACA,GAAA;AACI,IAAK,IAAA,CAAA,MAAA,EAAQ,YAAY,IAAI,CAAA,CAAA;AAAA,GACjC;AAAA,EAeA,aAAa,CAAI,GAAA,CAAA,EAAG,IAAI,CAAG,EAAA,MAAA,GAAS,GAAG,MAAS,GAAA,CAAA,EAAG,QAAW,GAAA,CAAA,EAAG,QAAQ,CAAG,EAAA,KAAA,GAAQ,GAAG,MAAS,GAAA,CAAA,EAAG,SAAS,CAC5G,EAAA;AACI,IAAA,IAAA,CAAK,SAAS,CAAI,GAAA,CAAA,CAAA;AAClB,IAAA,IAAA,CAAK,SAAS,CAAI,GAAA,CAAA,CAAA;AAClB,IAAA,IAAA,CAAK,KAAM,CAAA,CAAA,GAAI,CAAC,MAAA,GAAS,CAAI,GAAA,MAAA,CAAA;AAC7B,IAAA,IAAA,CAAK,KAAM,CAAA,CAAA,GAAI,CAAC,MAAA,GAAS,CAAI,GAAA,MAAA,CAAA;AAC7B,IAAA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;AAChB,IAAA,IAAA,CAAK,KAAK,CAAI,GAAA,KAAA,CAAA;AACd,IAAA,IAAA,CAAK,KAAK,CAAI,GAAA,KAAA,CAAA;AACd,IAAA,IAAA,CAAK,MAAM,CAAI,GAAA,MAAA,CAAA;AACf,IAAA,IAAA,CAAK,MAAM,CAAI,GAAA,MAAA,CAAA;AAEf,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EASA,QAAQ,QACR,EAAA;AACI,IAAA,IAAA,CAAK,gBAAiB,EAAA,CAAA;AAEtB,IAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;AAClB,IAAA,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;AAEjB,IAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;AACd,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AACf,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;AAEZ,IAAA,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;AAChB,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AACf,IAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;AAClB,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AAEf,IAAA,IAAA,CAAK,WAAc,GAAA,KAAA,CAAA;AACnB,IAAA,IAAA,CAAK,mBAAsB,GAAA,KAAA,CAAA;AAE3B,IAAA,IAAA,CAAK,KAAK,WAAW,CAAA,CAAA;AACrB,IAAA,IAAA,CAAK,kBAAmB,EAAA,CAAA;AAAA,GAC5B;AAAA,EAMA,IAAI,wBACJ,GAAA;AACI,IAAI,IAAA,IAAA,CAAK,4BAA4B,IACrC,EAAA;AAEI,MAAK,IAAA,CAAA,uBAAA,GAA0B,IAAI,sBAAuB,EAAA,CAAA;AAAA,KAC9D;AAEA,IAAA,OAAO,IAAK,CAAA,uBAAA,CAAA;AAAA,GAChB;AAAA,EAYA,gBACA,GAAA;AACI,IAAA,MAAM,WAAW,IAAK,CAAA,MAAA,CAAA;AAEtB,IAAA,IAAA,CAAK,SAAS,IAAK,CAAA,wBAAA,CAAA;AAEnB,IAAO,OAAA,QAAA,CAAA;AAAA,GACX;AAAA,EAMA,kBAAkB,WAClB,EAAA;AACI,IAAA,IAAA,CAAK,MAAS,GAAA,WAAA,CAAA;AAAA,GAClB;AAAA,EAMA,IAAI,CACJ,GAAA;AACI,IAAA,OAAO,KAAK,QAAS,CAAA,CAAA,CAAA;AAAA,GACzB;AAAA,EAEA,IAAI,EAAE,KACN,EAAA;AACI,IAAK,IAAA,CAAA,SAAA,CAAU,SAAS,CAAI,GAAA,KAAA,CAAA;AAAA,GAChC;AAAA,EAMA,IAAI,CACJ,GAAA;AACI,IAAA,OAAO,KAAK,QAAS,CAAA,CAAA,CAAA;AAAA,GACzB;AAAA,EAEA,IAAI,EAAE,KACN,EAAA;AACI,IAAK,IAAA,CAAA,SAAA,CAAU,SAAS,CAAI,GAAA,KAAA,CAAA;AAAA,GAChC;AAAA,EAMA,IAAI,cACJ,GAAA;AACI,IAAA,OAAO,KAAK,SAAU,CAAA,cAAA,CAAA;AAAA,GAC1B;AAAA,EAMA,IAAI,cACJ,GAAA;AACI,IAAA,OAAO,KAAK,SAAU,CAAA,cAAA,CAAA;AAAA,GAC1B;AAAA,EAMA,IAAI,QACJ,GAAA;AACI,IAAA,OAAO,KAAK,SAAU,CAAA,QAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAI,SAAS,KACb,EAAA;AACI,IAAK,IAAA,CAAA,SAAA,CAAU,QAAS,CAAA,QAAA,CAAS,KAAK,CAAA,CAAA;AAAA,GAC1C;AAAA,EAQA,IAAI,KACJ,GAAA;AACI,IAAA,OAAO,KAAK,SAAU,CAAA,KAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAI,MAAM,KACV,EAAA;AACI,IAAK,IAAA,CAAA,SAAA,CAAU,KAAM,CAAA,QAAA,CAAS,KAAK,CAAA,CAAA;AAAA,GACvC;AAAA,EASA,IAAI,KACJ,GAAA;AACI,IAAA,OAAO,KAAK,SAAU,CAAA,KAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAI,MAAM,KACV,EAAA;AACI,IAAK,IAAA,CAAA,SAAA,CAAU,KAAM,CAAA,QAAA,CAAS,KAAK,CAAA,CAAA;AAAA,GACvC;AAAA,EAMA,IAAI,IACJ,GAAA;AACI,IAAA,OAAO,KAAK,SAAU,CAAA,IAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAI,KAAK,KACT,EAAA;AACI,IAAK,IAAA,CAAA,SAAA,CAAU,IAAK,CAAA,QAAA,CAAS,KAAK,CAAA,CAAA;AAAA,GACtC;AAAA,EAMA,IAAI,QACJ,GAAA;AACI,IAAA,OAAO,KAAK,SAAU,CAAA,QAAA,CAAA;AAAA,GAC1B;AAAA,EAEA,IAAI,SAAS,KACb,EAAA;AACI,IAAA,IAAA,CAAK,UAAU,QAAW,GAAA,KAAA,CAAA;AAAA,GAC9B;AAAA,EAMA,IAAI,KACJ,GAAA;AACI,IAAO,OAAA,IAAA,CAAK,UAAU,QAAW,GAAAE,eAAA,CAAA;AAAA,GACrC;AAAA,EAEA,IAAI,MAAM,KACV,EAAA;AACI,IAAK,IAAA,CAAA,SAAA,CAAU,WAAW,KAAQ,GAAAC,eAAA,CAAA;AAAA,GACtC;AAAA,EAUA,IAAI,MACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,OAAA,CAAA;AAAA,GAChB;AAAA,EAEA,IAAI,OAAO,KACX,EAAA;AACI,IAAA,IAAA,CAAK,OAAU,GAAA,KAAA,CAAA;AACf,IAAA,IAAI,KAAK,MACT,EAAA;AACI,MAAA,IAAA,CAAK,OAAO,SAAY,GAAA,IAAA,CAAA;AAAA,KAC5B;AAAA,GACJ;AAAA,EAMA,IAAI,YACJ,GAAA;AACI,IAAA,IAAI,IAAO,GAAA,IAAA,CAAA;AAEX,IACA,GAAA;AACI,MAAI,IAAA,CAAC,KAAK,OACV,EAAA;AACI,QAAO,OAAA,KAAA,CAAA;AAAA,OACX;AAEA,MAAA,IAAA,GAAO,IAAK,CAAA,MAAA,CAAA;AAAA,KACP,QAAA,IAAA,EAAA;AAET,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EAuBA,IAAI,IACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,KAAA,CAAA;AAAA,GAChB;AAAA,EAEA,IAAI,KAAK,KACT,EAAA;AACI,IAAI,IAAA,IAAA,CAAK,UAAU,KACnB,EAAA;AACI,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAI,KAAK,KACT,EAAA;AACI,MAAA,MAAM,aAAe,IAAK,CAAA,KAAA,CAAmB,aACtC,IAAK,CAAA,KAAA,CAAmB,aAAa,IAAK,CAAA,KAAA,CAAA;AAEjD,MAAA,IAAI,UACJ,EAAA;AACI,QAAW,UAAA,CAAA,aAAA,EAAA,CAAA;AAEX,QAAI,IAAA,UAAA,CAAW,kBAAkB,CACjC,EAAA;AACI,UAAA,UAAA,CAAW,UAAa,GAAA,IAAA,CAAA;AACxB,UAAA,UAAA,CAAW,MAAS,GAAA,KAAA,CAAA;AAAA,SACxB;AAAA,OACJ;AAAA,KACJ;AAEA,IAAA,IAAA,CAAK,KAAQ,GAAA,KAAA,CAAA;AAEb,IAAA,IAAI,KAAK,KACT,EAAA;AACI,MAAA,MAAM,aAAe,IAAK,CAAA,KAAA,CAAmB,aACtC,IAAK,CAAA,KAAA,CAAmB,aAAa,IAAK,CAAA,KAAA,CAAA;AAEjD,MAAA,IAAI,UACJ,EAAA;AACI,QAAI,IAAA,UAAA,CAAW,kBAAkB,CACjC,EAAA;AACI,UAAA,UAAA,CAAW,UAAa,GAAA,KAAA,CAAA;AACxB,UAAA,UAAA,CAAW,MAAS,GAAA,IAAA,CAAA;AAAA,SACxB;AAEA,QAAW,UAAA,CAAA,aAAA,EAAA,CAAA;AAAA,OACf;AAAA,KACJ;AAAA,GACJ;AACJ,CAAA;AAKO,MAAM,+BAA+B,aAC5C,CAAA;AAAA,EADO,WAAA,GAAA;AAAA,IAAA,KAAA,CAAA,GAAA,SAAA,CAAA,CAAA;AAKH,IAAqB,IAAA,CAAA,SAAA,GAAA,IAAA,CAAA;AAAA,GAAA;AACzB,CAAA;AAQA,aAAc,CAAA,SAAA,CAAU,4BAA+B,GAAA,aAAA,CAAc,SAAU,CAAA,eAAA;;;;;"}