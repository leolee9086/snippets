{"version":3,"file":"loadKTX.mjs","sources":["../../src/loaders/loadKTX.ts"],"sourcesContent":["import { ALPHA_MODES, MIPMAP_MODES, settings, utils, BaseTexture, extensions, ExtensionType } from 'pixijs/core';\nimport { checkExtension, createTexture, LoaderParserPriority } from 'pixijs/assets';\nimport { parseKTX } from '../parsers';\n\nimport type { IBaseTextureOptions, Texture } from 'pixijs/core';\nimport type { LoadAsset, Loader, LoaderParser } from 'pixijs/assets';\n\n/** Loads KTX textures! */\nexport const loadKTX = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    test(url: string): boolean\n    {\n        return checkExtension(url, '.ktx');\n    },\n\n    async load(url: string, asset: LoadAsset, loader: Loader): Promise<Texture | Texture[]>\n    {\n        // get an array buffer...\n        const response = await settings.ADAPTER.fetch(url);\n\n        const arrayBuffer = await response.arrayBuffer();\n\n        const { compressed, uncompressed, kvData } = parseKTX(url, arrayBuffer);\n\n        const resources = compressed ?? uncompressed;\n\n        const options = {\n            mipmap: MIPMAP_MODES.OFF,\n            alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n            resolution: utils.getResolutionOfUrl(url),\n            ...asset.data,\n        };\n\n        const textures = resources.map((resource) =>\n        {\n            if (resources === uncompressed)\n            {\n                Object.assign(options, {\n                    type: (resource as typeof uncompressed[0]).type,\n                    format: (resource as typeof uncompressed[0]).format,\n                });\n            }\n\n            const base = new BaseTexture(resource, options);\n\n            base.ktxKeyValueData = kvData;\n\n            return createTexture(base, loader, url);\n        });\n\n        return textures.length === 1 ? textures[0] : textures;\n    },\n\n    unload(texture: Texture | Texture[]): void\n    {\n        if (Array.isArray(texture))\n        {\n            texture.forEach((t) => t.destroy(true));\n        }\n        else\n        {\n            texture.destroy(true);\n        }\n    }\n\n} as LoaderParser<Texture | Texture[], IBaseTextureOptions>;\n\nextensions.add(loadKTX);\n"],"names":[],"mappings":";;;;;AAQO,MAAM,OAAU,GAAA;AAAA,EACnB,SAAW,EAAA;AAAA,IACP,MAAM,aAAc,CAAA,UAAA;AAAA,IACpB,UAAU,oBAAqB,CAAA,IAAA;AAAA,GACnC;AAAA,EAEA,KAAK,GACL,EAAA;AACI,IAAO,OAAA,cAAA,CAAe,KAAK,MAAM,CAAA,CAAA;AAAA,GACrC;AAAA,EAEA,MAAM,IAAA,CAAK,GAAa,EAAA,KAAA,EAAkB,MAC1C,EAAA;AAEI,IAAA,MAAM,QAAW,GAAA,MAAM,QAAS,CAAA,OAAA,CAAQ,MAAM,GAAG,CAAA,CAAA;AAEjD,IAAM,MAAA,WAAA,GAAc,MAAM,QAAA,CAAS,WAAY,EAAA,CAAA;AAE/C,IAAA,MAAM,EAAE,UAAY,EAAA,YAAA,EAAc,MAAW,EAAA,GAAA,QAAA,CAAS,KAAK,WAAW,CAAA,CAAA;AAEtE,IAAA,MAAM,YAAY,UAAc,IAAA,YAAA,CAAA;AAEhC,IAAA,MAAM,OAAU,GAAA;AAAA,MACZ,QAAQ,YAAa,CAAA,GAAA;AAAA,MACrB,WAAW,WAAY,CAAA,sBAAA;AAAA,MACvB,UAAA,EAAY,KAAM,CAAA,kBAAA,CAAmB,GAAG,CAAA;AAAA,MACxC,GAAG,KAAM,CAAA,IAAA;AAAA,KACb,CAAA;AAEA,IAAA,MAAM,QAAW,GAAA,SAAA,CAAU,GAAI,CAAA,CAAC,QAChC,KAAA;AACI,MAAA,IAAI,cAAc,YAClB,EAAA;AACI,QAAA,MAAA,CAAO,OAAO,OAAS,EAAA;AAAA,UACnB,MAAO,QAAoC,CAAA,IAAA;AAAA,UAC3C,QAAS,QAAoC,CAAA,MAAA;AAAA,SAChD,CAAA,CAAA;AAAA,OACL;AAEA,MAAA,MAAM,IAAO,GAAA,IAAI,WAAY,CAAA,QAAA,EAAU,OAAO,CAAA,CAAA;AAE9C,MAAA,IAAA,CAAK,eAAkB,GAAA,MAAA,CAAA;AAEvB,MAAO,OAAA,aAAA,CAAc,IAAM,EAAA,MAAA,EAAQ,GAAG,CAAA,CAAA;AAAA,KACzC,CAAA,CAAA;AAED,IAAA,OAAO,QAAS,CAAA,MAAA,KAAW,CAAI,GAAA,QAAA,CAAS,CAAK,CAAA,GAAA,QAAA,CAAA;AAAA,GACjD;AAAA,EAEA,OAAO,OACP,EAAA;AACI,IAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,OAAO,CACzB,EAAA;AACI,MAAA,OAAA,CAAQ,QAAQ,CAAC,CAAA,KAAM,CAAE,CAAA,OAAA,CAAQ,IAAI,CAAC,CAAA,CAAA;AAAA,KAG1C,MAAA;AACI,MAAA,OAAA,CAAQ,QAAQ,IAAI,CAAA,CAAA;AAAA,KACxB;AAAA,GACJ;AAEJ,EAAA;AAEA,UAAA,CAAW,IAAI,OAAO,CAAA;;;;"}