'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var compressedTextures = require('pixijs/compressed-textures');
var core = require('pixijs/core');
var Basis = require('../Basis.js');
var TranscoderWorker = require('../TranscoderWorker.js');

const _BasisParser = class {
  static async transcode(arrayBuffer) {
    let resources;
    if (typeof Worker !== "undefined" && _BasisParser.TranscoderWorker.wasmSource) {
      resources = await _BasisParser.transcodeAsync(arrayBuffer);
    } else {
      resources = _BasisParser.transcodeSync(arrayBuffer);
    }
    return resources;
  }
  static async transcodeAsync(arrayBuffer) {
    if (!_BasisParser.defaultRGBAFormat && !_BasisParser.defaultRGBFormat) {
      _BasisParser.autoDetectFormats();
    }
    const workerPool = _BasisParser.workerPool;
    let leastLoad = 268435456;
    let worker = null;
    for (let i = 0, j = workerPool.length; i < j; i++) {
      if (workerPool[i].load < leastLoad) {
        worker = workerPool[i];
        leastLoad = worker.load;
      }
    }
    if (!worker) {
      worker = new TranscoderWorker.TranscoderWorker();
      workerPool.push(worker);
    }
    await worker.initAsync();
    const response = await worker.transcodeAsync(new Uint8Array(arrayBuffer), _BasisParser.defaultRGBAFormat.basisFormat, _BasisParser.defaultRGBFormat.basisFormat);
    const basisFormat = response.basisFormat;
    const imageArray = response.imageArray;
    const fallbackMode = basisFormat > 12;
    let imageResources;
    if (!fallbackMode) {
      const format = Basis.BASIS_FORMAT_TO_INTERNAL_FORMAT[response.basisFormat];
      imageResources = new Array(imageArray.length);
      for (let i = 0, j = imageArray.length; i < j; i++) {
        imageResources[i] = new compressedTextures.CompressedTextureResource(null, {
          format,
          width: imageArray[i].width,
          height: imageArray[i].height,
          levelBuffers: imageArray[i].levelArray,
          levels: imageArray[i].levelArray.length
        });
      }
    } else {
      imageResources = imageArray.map((image) => new core.BufferResource(new Uint16Array(image.levelArray[0].levelBuffer.buffer), {
        width: image.width,
        height: image.height
      }));
    }
    imageResources.basisFormat = basisFormat;
    return imageResources;
  }
  static transcodeSync(arrayBuffer) {
    if (!_BasisParser.defaultRGBAFormat && !_BasisParser.defaultRGBFormat) {
      _BasisParser.autoDetectFormats();
    }
    const BASIS = _BasisParser.basisBinding;
    const data = new Uint8Array(arrayBuffer);
    const basisFile = new BASIS.BasisFile(data);
    const imageCount = basisFile.getNumImages();
    const hasAlpha = basisFile.getHasAlpha();
    const basisFormat = hasAlpha ? _BasisParser.defaultRGBAFormat.basisFormat : _BasisParser.defaultRGBFormat.basisFormat;
    const basisFallbackFormat = Basis.BASIS_FORMATS.cTFRGB565;
    const imageResources = new Array(imageCount);
    let fallbackMode = _BasisParser.fallbackMode;
    if (!basisFile.startTranscoding()) {
      basisFile.close();
      basisFile.delete();
      return null;
    }
    for (let i = 0; i < imageCount; i++) {
      const levels = !fallbackMode ? basisFile.getNumLevels(i) : 1;
      const width = basisFile.getImageWidth(i, 0);
      const height = basisFile.getImageHeight(i, 0);
      const alignedWidth = width + 3 & ~3;
      const alignedHeight = height + 3 & ~3;
      const imageLevels = new Array(levels);
      for (let j = 0; j < levels; j++) {
        const levelWidth = basisFile.getImageWidth(i, j);
        const levelHeight = basisFile.getImageHeight(i, j);
        const byteSize = basisFile.getImageTranscodedSizeInBytes(i, 0, !fallbackMode ? basisFormat : basisFallbackFormat);
        imageLevels[j] = {
          levelID: j,
          levelBuffer: new Uint8Array(byteSize),
          levelWidth,
          levelHeight
        };
        if (!basisFile.transcodeImage(imageLevels[j].levelBuffer, i, 0, !fallbackMode ? basisFormat : basisFallbackFormat, false, false)) {
          if (fallbackMode) {
            break;
          } else {
            i = -1;
            fallbackMode = true;
            continue;
          }
        }
      }
      let imageResource;
      if (!fallbackMode) {
        imageResource = new compressedTextures.CompressedTextureResource(null, {
          format: Basis.BASIS_FORMAT_TO_INTERNAL_FORMAT[basisFormat],
          width: alignedWidth,
          height: alignedHeight,
          levelBuffers: imageLevels,
          levels
        });
      } else {
        imageResource = new core.BufferResource(new Uint16Array(imageLevels[0].levelBuffer.buffer), { width, height });
      }
      imageResources[i] = imageResource;
    }
    basisFile.close();
    basisFile.delete();
    const transcodedResources = imageResources;
    transcodedResources.basisFormat = !fallbackMode ? basisFormat : basisFallbackFormat;
    return transcodedResources;
  }
  static autoDetectFormats(extensions) {
    if (!extensions) {
      const canvas = core.settings.ADAPTER.createCanvas();
      const gl = canvas.getContext("webgl");
      if (!gl) {
        console.error("WebGL not available for BASIS transcoding. Silently failing.");
        return;
      }
      extensions = {
        s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        astc: gl.getExtension("WEBGL_compressed_texture_astc"),
        etc: gl.getExtension("WEBGL_compressed_texture_etc"),
        etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: gl.getExtension("WEBGL_compressed_texture_atc")
      };
    }
    const supportedFormats = {};
    for (const key in extensions) {
      const extension = extensions[key];
      if (!extension) {
        continue;
      }
      Object.assign(supportedFormats, Object.getPrototypeOf(extension));
    }
    for (let i = 0; i < 2; i++) {
      const detectWithAlpha = !!i;
      let internalFormat;
      let basisFormat;
      for (const id in supportedFormats) {
        internalFormat = supportedFormats[id];
        basisFormat = Basis.INTERNAL_FORMAT_TO_BASIS_FORMAT[internalFormat];
        if (basisFormat !== void 0) {
          if (detectWithAlpha && Basis.BASIS_FORMATS_ALPHA[basisFormat] || !detectWithAlpha && !Basis.BASIS_FORMATS_ALPHA[basisFormat]) {
            break;
          }
        }
      }
      if (internalFormat) {
        _BasisParser[detectWithAlpha ? "defaultRGBAFormat" : "defaultRGBFormat"] = {
          textureFormat: internalFormat,
          basisFormat
        };
      } else {
        _BasisParser[detectWithAlpha ? "defaultRGBAFormat" : "defaultRGBFormat"] = {
          textureFormat: core.TYPES.UNSIGNED_SHORT_5_6_5,
          basisFormat: Basis.BASIS_FORMATS.cTFRGB565
        };
        _BasisParser.fallbackMode = true;
      }
    }
  }
  static bindTranscoder(basisLibrary) {
    _BasisParser.basisBinding = basisLibrary;
  }
  static loadTranscoder(jsURL, wasmURL) {
    return _BasisParser.TranscoderWorker.loadTranscoder(jsURL, wasmURL);
  }
  static setTranscoder(jsSource, wasmSource) {
    _BasisParser.TranscoderWorker.setTranscoder(jsSource, wasmSource);
  }
  static get TRANSCODER_WORKER_POOL_LIMIT() {
    return this.workerPool.length || 1;
  }
  static set TRANSCODER_WORKER_POOL_LIMIT(limit) {
    for (let i = this.workerPool.length; i < limit; i++) {
      this.workerPool[i] = new TranscoderWorker.TranscoderWorker();
      this.workerPool[i].initAsync();
    }
  }
};
let BasisParser = _BasisParser;
BasisParser.fallbackMode = false;
BasisParser.workerPool = [];
BasisParser.TranscoderWorker = TranscoderWorker.TranscoderWorker;

exports.BasisParser = BasisParser;
//# sourceMappingURL=BasisParser.js.map
