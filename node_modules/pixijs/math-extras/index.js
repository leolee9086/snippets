'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('./pointExtras.js');
require('./rectangleExtras.js');
var core = require('pixijs/core');

function floatEqual(a, b, epsilon = Number.EPSILON) {
  if (a === b) {
    return true;
  }
  const diff = Math.abs(a - b);
  return diff < epsilon;
}
function genericLineIntersection(aStart, aEnd, bStart, bEnd, isLine, outPoint) {
  if (!outPoint) {
    outPoint = new core.Point();
  }
  const dxa = aEnd.x - aStart.x;
  const dya = aEnd.y - aStart.y;
  const dxb = bEnd.x - bStart.x;
  const dyb = bEnd.y - bStart.y;
  const denominator = dyb * dxa - dxb * dya;
  if (floatEqual(denominator, 0)) {
    outPoint.x = NaN;
    outPoint.y = NaN;
    return outPoint;
  }
  const ua = (dxb * (aStart.y - bStart.y) - dyb * (aStart.x - bStart.x)) / denominator;
  const ub = (dxa * (aStart.y - bStart.y) - dya * (aStart.x - bStart.x)) / denominator;
  if (!isLine && (ua < 0 || ua > 1 || ub < 0 || ub > 1)) {
    outPoint.x = NaN;
    outPoint.y = NaN;
    return outPoint;
  }
  outPoint.x = aStart.x + ua * dxa;
  outPoint.y = bStart.y + ub * dyb;
  return outPoint;
}
function lineIntersection(aStart, aEnd, bStart, bEnd, outPoint) {
  return genericLineIntersection(aStart, aEnd, bStart, bEnd, true, outPoint);
}
function segmentIntersection(aStart, aEnd, bStart, bEnd, outPoint) {
  return genericLineIntersection(aStart, aEnd, bStart, bEnd, false, outPoint);
}

exports.floatEqual = floatEqual;
exports.lineIntersection = lineIntersection;
exports.segmentIntersection = segmentIntersection;
//# sourceMappingURL=index.js.map
