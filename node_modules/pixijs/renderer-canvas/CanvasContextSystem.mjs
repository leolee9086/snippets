import { Matrix, BLEND_MODES, settings, SCALE_MODES, ExtensionType, extensions } from 'pixijs/core';
import { mapCanvasBlendModesToPixi } from './utils/mapCanvasBlendModesToPixi.mjs';

const tempMatrix = new Matrix();
class CanvasContextSystem {
  constructor(renderer) {
    this.activeResolution = 1;
    this.smoothProperty = "imageSmoothingEnabled";
    this.blendModes = mapCanvasBlendModesToPixi();
    this._activeBlendMode = null;
    this._projTransform = null;
    this._outerBlend = false;
    this.renderer = renderer;
  }
  init() {
    const alpha = this.renderer.background.alpha < 1;
    this.rootContext = this.renderer.view.getContext("2d", { alpha });
    this.activeContext = this.rootContext;
    if (!this.rootContext.imageSmoothingEnabled) {
      const rc = this.rootContext;
      if (rc.webkitImageSmoothingEnabled) {
        this.smoothProperty = "webkitImageSmoothingEnabled";
      } else if (rc.mozImageSmoothingEnabled) {
        this.smoothProperty = "mozImageSmoothingEnabled";
      } else if (rc.oImageSmoothingEnabled) {
        this.smoothProperty = "oImageSmoothingEnabled";
      } else if (rc.msImageSmoothingEnabled) {
        this.smoothProperty = "msImageSmoothingEnabled";
      }
    }
  }
  setContextTransform(transform, roundPixels, localResolution) {
    let mat = transform;
    const proj = this._projTransform;
    const contextResolution = this.activeResolution;
    localResolution = localResolution || contextResolution;
    if (proj) {
      mat = tempMatrix;
      mat.copyFrom(transform);
      mat.prepend(proj);
    }
    if (roundPixels) {
      this.activeContext.setTransform(mat.a * localResolution, mat.b * localResolution, mat.c * localResolution, mat.d * localResolution, mat.tx * contextResolution | 0, mat.ty * contextResolution | 0);
    } else {
      this.activeContext.setTransform(mat.a * localResolution, mat.b * localResolution, mat.c * localResolution, mat.d * localResolution, mat.tx * contextResolution, mat.ty * contextResolution);
    }
  }
  clear(clearColor, alpha) {
    const { activeContext: context, renderer } = this;
    clearColor = clearColor ?? this.renderer.background.colorString;
    context.clearRect(0, 0, renderer.width, renderer.height);
    if (clearColor) {
      context.globalAlpha = alpha ?? this.renderer.background.alpha;
      context.fillStyle = clearColor;
      context.fillRect(0, 0, renderer.width, renderer.height);
      context.globalAlpha = 1;
    }
  }
  setBlendMode(blendMode, readyForOuterBlend) {
    const outerBlend = blendMode === BLEND_MODES.SRC_IN || blendMode === BLEND_MODES.SRC_OUT || blendMode === BLEND_MODES.DST_IN || blendMode === BLEND_MODES.DST_ATOP;
    if (!readyForOuterBlend && outerBlend) {
      blendMode = BLEND_MODES.NORMAL;
    }
    if (this._activeBlendMode === blendMode) {
      return;
    }
    this._activeBlendMode = blendMode;
    this._outerBlend = outerBlend;
    this.activeContext.globalCompositeOperation = this.blendModes[blendMode];
  }
  resize() {
    if (this.smoothProperty) {
      this.rootContext[this.smoothProperty] = settings.SCALE_MODE === SCALE_MODES.LINEAR;
    }
  }
  invalidateBlendMode() {
    this._activeBlendMode = this.blendModes.indexOf(this.activeContext.globalCompositeOperation);
  }
  destroy() {
    this.renderer = null;
    this.rootContext = null;
    this.activeContext = null;
    this.smoothProperty = null;
  }
}
CanvasContextSystem.extension = {
  type: ExtensionType.CanvasRendererSystem,
  name: "canvasContext"
};
extensions.add(CanvasContextSystem);

export { CanvasContextSystem };
//# sourceMappingURL=CanvasContextSystem.mjs.map
