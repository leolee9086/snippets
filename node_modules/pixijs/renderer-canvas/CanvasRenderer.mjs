import { utils, SystemManager, settings, ExtensionType, extensions } from 'pixijs/core';

const { deprecation } = utils;
const _CanvasRenderer = class extends SystemManager {
  constructor(options) {
    super();
    this.rendererLogId = "Canvas";
    options = Object.assign({}, settings.RENDER_OPTIONS, options);
    const systemConfig = {
      runners: ["init", "destroy", "contextChange", "reset", "update", "postrender", "prerender", "resize"],
      systems: _CanvasRenderer.__systems,
      priority: [
        "textureGenerator",
        "background",
        "_view",
        "_plugin",
        "startup",
        "mask",
        "canvasContext",
        "objectRenderer"
      ]
    };
    this.setup(systemConfig);
    const startupOptions = {
      hello: options.hello,
      _plugin: _CanvasRenderer.__plugins,
      background: {
        alpha: options.backgroundAlpha,
        color: options.background ?? options.backgroundColor,
        clearBeforeRender: options.clearBeforeRender
      },
      _view: {
        height: options.height,
        width: options.width,
        autoDensity: options.autoDensity,
        resolution: options.resolution
      }
    };
    this.startup.run(startupOptions);
  }
  static test() {
    return true;
  }
  generateTexture(displayObject, options) {
    return this.textureGenerator.generateTexture(displayObject, options);
  }
  reset() {
  }
  render(displayObject, options) {
    this.objectRenderer.render(displayObject, options);
  }
  clear() {
    this.canvasContext.clear();
  }
  destroy(removeView) {
    this.runners.destroy.items.reverse();
    this.emitWithCustomOptions(this.runners.destroy, {
      _view: removeView
    });
    super.destroy();
  }
  get plugins() {
    return this._plugin.plugins;
  }
  resize(desiredScreenWidth, desiredScreenHeight) {
    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
  }
  get width() {
    return this._view.element.width;
  }
  get height() {
    return this._view.element.height;
  }
  get resolution() {
    return this._view.resolution;
  }
  get autoDensity() {
    return this._view.autoDensity;
  }
  get view() {
    return this._view.element;
  }
  get screen() {
    return this._view.screen;
  }
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  get clearBeforeRender() {
    return this.background.clearBeforeRender;
  }
  get blendModes() {
    return this.canvasContext.blendModes;
  }
  get maskManager() {
    deprecation("7.0.0", "renderer.maskManager has been deprecated, please use renderer.mask instead");
    return this.mask;
  }
  get refresh() {
    return true;
  }
  get rootContext() {
    return this.canvasContext.rootContext;
  }
  get context() {
    return this.canvasContext.activeContext;
  }
  get smoothProperty() {
    return this.canvasContext.smoothProperty;
  }
  setBlendMode(blendMode, readyForOuterBlend) {
    this.canvasContext.setBlendMode(blendMode, readyForOuterBlend);
  }
  invalidateBlendMode() {
    this.canvasContext.invalidateBlendMode();
  }
  setContextTransform(transform, roundPixels, localResolution) {
    this.canvasContext.setContextTransform(transform, roundPixels, localResolution);
  }
  get backgroundColor() {
    return this.background.color;
  }
  set backgroundColor(value) {
    this.background.color = value;
  }
  get backgroundAlpha() {
    return this.background.color;
  }
  set backgroundAlpha(value) {
    this.background.alpha = value;
  }
  get preserveDrawingBuffer() {
    return false;
  }
  get useContextAlpha() {
    return false;
  }
};
let CanvasRenderer = _CanvasRenderer;
CanvasRenderer.extension = {
  type: ExtensionType.Renderer,
  priority: 0
};
CanvasRenderer.__plugins = {};
CanvasRenderer.__systems = {};
extensions.handleByMap(ExtensionType.CanvasRendererPlugin, CanvasRenderer.__plugins);
extensions.handleByMap(ExtensionType.CanvasRendererSystem, CanvasRenderer.__systems);
extensions.add(CanvasRenderer);

export { CanvasRenderer };
//# sourceMappingURL=CanvasRenderer.mjs.map
